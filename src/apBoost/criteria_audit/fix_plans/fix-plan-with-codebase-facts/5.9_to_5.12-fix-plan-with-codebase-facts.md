# Section 5.9 to 5.12 - Fix Plan with Codebase Facts

> **What is this file?**
> This document combines two resources for implementing criteria section 5.9 to 5.12:
> 1. **Fix Plan** - Step-by-step implementation instructions for code changes
> 2. **Codebase Facts** - Relevant code snippets, file paths, and existing patterns from the codebase
>
> Use the Fix Plan as your guide and reference the Codebase Facts for accurate file locations and code context.

---

## Part 1: Fix Plan

# Fix Plan: Sections 5.9 to 5.12

**Planned by:** Claude Agent
**Date:** 2026-01-14
**Status:** COMPLETE
**Based on Audit:** section_5.9_to_5.12_criteria_audit.md

## Executive Summary
- Total Issues: 14
- ⚠️ Partial Implementations: 9
- ❌ Missing Features: 5
- ❓ Needs Investigation: 0
- Estimated Complexity: High

---

## Issue 1: Queue Reconciliation on Resume (5.9 - Multiple Criteria)

### Audit Finding
- **Status:** ❌ Missing (5 criteria)
- **Criteria:**
  1. Check IndexedDB for pending queue items
  2. For each item: compare localTimestamp vs session.lastModified
  3. If item newer: apply to Firestore, delete from queue
  4. If item older: discard (stale)
  5. Use Firestore state (now authoritative)
- **Current State:** On session resume, `useTestSession.js` loads Firestore state but does NOT check for pending IndexedDB queue items. The `useOfflineQueue` hook initializes IndexedDB but only counts items with `updateQueueLength()`, never reconciles them.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useTestSession.js` (lines 159-206) - `loadTestAndSession()` function loads session but doesn't reconcile queue
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 106-122) - `updateQueueLength()` only counts, doesn't compare timestamps
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 131-138) - Queue items store `localTimestamp: Date.now()` but never use it
  - `src/apBoost/services/apSessionService.js` (lines 63-65) - Session has `lastAction: serverTimestamp()` that could be used for comparison

- **Current Implementation:**
  - `useOfflineQueue` initializes IndexedDB and stores items with `localTimestamp`
  - On resume, `getActiveSession()` loads Firestore session
  - `useOfflineQueue` just counts pending items, no reconciliation
  - If old browser/tab had pending items, they remain and may later overwrite newer Firestore data

- **Gap:** Complete absence of timestamp comparison and reconciliation logic. The pieces exist (queue with timestamps, session with lastAction) but they're never compared.

- **Dependencies:**
  - `useTestSession` depends on `useOfflineQueue`
  - `useOfflineQueue` needs access to session's `lastAction` timestamp for comparison
  - Must handle Firestore's `serverTimestamp()` which is a special marker on write

### Fix Plan

#### Step 1: Add queue reconciliation method to useOfflineQueue
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add new function `reconcileQueue`
**Details:**
- Add new exported function `reconcileQueue(sessionLastAction)` that:
  1. Gets all pending items from IndexedDB for this session
  2. For each item, compares `item.localTimestamp` against `sessionLastAction.toMillis()`
  3. Items with `localTimestamp > sessionLastAction`: keep for flushing (they're newer)
  4. Items with `localTimestamp <= sessionLastAction`: delete from queue (they're stale)
- Return an object: `{ keptItems: count, discardedItems: count }`
- Pattern to follow: Similar to `flushQueue()` function at lines 173-266

```javascript
// Add after line 265, before cleanup useEffect
const reconcileQueue = useCallback(async (sessionLastAction) => {
  if (!dbRef.current || !sessionId) return { keptItems: 0, discardedItems: 0 }

  try {
    const tx = dbRef.current.transaction(STORE_NAME, 'readonly')
    const store = tx.objectStore(STORE_NAME)
    const index = store.index('sessionId')
    const request = index.getAll(IDBKeyRange.only(sessionId))

    const items = await new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result)
      request.onerror = () => reject(request.error)
    })

    // Convert serverTimestamp to milliseconds
    const lastActionMs = sessionLastAction?.toMillis?.() || sessionLastAction?.seconds * 1000 || 0

    const itemsToDiscard = items.filter(item => item.localTimestamp <= lastActionMs)
    const itemsToKeep = items.filter(item => item.localTimestamp > lastActionMs)

    // Delete stale items
    if (itemsToDiscard.length > 0) {
      const deleteTx = dbRef.current.transaction(STORE_NAME, 'readwrite')
      const deleteStore = deleteTx.objectStore(STORE_NAME)

      for (const item of itemsToDiscard) {
        deleteStore.delete(item.id)
      }

      await new Promise((resolve, reject) => {
        deleteTx.oncomplete = resolve
        deleteTx.onerror = () => reject(deleteTx.error)
      })

      logDebug('useOfflineQueue.reconcileQueue',
        `Discarded ${itemsToDiscard.length} stale items, kept ${itemsToKeep.length}`)
    }

    await updateQueueLength()
    return { keptItems: itemsToKeep.length, discardedItems: itemsToDiscard.length }
  } catch (error) {
    logError('useOfflineQueue.reconcileQueue', { sessionId }, error)
    return { keptItems: 0, discardedItems: 0 }
  }
}, [sessionId, updateQueueLength])
```

#### Step 2: Export reconcileQueue from useOfflineQueue
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Modify return statement at line 277-283
**Details:**
- Add `reconcileQueue` to the returned object

#### Step 3: Call reconcileQueue on session resume
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Modify `loadTestAndSession()` function at lines 176-196
**Details:**
- After loading `existingSession`, call `reconcileQueue(existingSession.lastAction)`
- If there are kept items, schedule a flush
- This requires `reconcileQueue` to be available in useTestSession (need to import from useOfflineQueue or pass via ref)

**Challenge:** `useOfflineQueue` is called at line 50, after session is loaded. Need to restructure:
1. Option A: Pass reconcileQueue callback, call it when existingSession is loaded
2. Option B: Add a `useEffect` that watches for session and reconciles
3. **Recommended Option C:** Create a new `useQueueReconciliation` hook that handles this

```javascript
// Inside loadTestAndSession(), after line 195:
// Reconcile pending queue items with session timestamp
if (existingSession.lastAction) {
  // This will be called via a ref or effect
  const { keptItems, discardedItems } = await reconcileQueueRef.current?.(existingSession.lastAction) || {}
  if (keptItems > 0) {
    // Schedule flush for kept (newer) items
    scheduleFlushRef.current?.(1000)
  }
}
```

#### Step 4: Handle Firestore serverTimestamp conversion
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Handle both Firestore Timestamp and raw values
**Details:**
- Firestore `serverTimestamp()` returns a sentinel on write
- On read, it returns a Timestamp object with `.toMillis()` method
- Also handle cases where it might be `{ seconds, nanoseconds }` format

### Verification Steps
1. Start a test, answer some questions, then kill the browser process (not graceful close)
2. Reopen browser, navigate to same test - verify queue items are present
3. Answer more questions in resumed session, then close gracefully
4. Check Firestore - verify older queue items didn't overwrite newer answers
5. Test with intentional stale data: answer Q1 as "A", kill browser, answer Q1 as "B" on another device, resume first browser - "B" should remain

### Potential Risks
- **Risk:** Timestamp precision issues between client Date.now() and server timestamps
  - **Mitigation:** Use a small buffer (e.g., 1000ms) when comparing to account for clock drift
- **Risk:** Race condition if flush happens during reconciliation
  - **Mitigation:** Set a flag to prevent flush during reconciliation

---

## Issue 2: PAUSED Status on Browser Close (5.9)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Show "Resume" modal if status was PAUSED
- **Current State:** InstructionScreen checks for `IN_PROGRESS` status, but the system never sets `PAUSED`. The `beforeunload` handler only shows a warning, doesn't update session status.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useTestSession.js` (lines 208-220) - `beforeunload` handler only shows warning
  - `src/apBoost/hooks/useDuplicateTabGuard.js` (lines 114-126) - Comment says "We don't clear the session token..."
  - `src/apBoost/components/InstructionScreen.jsx` (line 19) - Checks `IN_PROGRESS`, not `PAUSED`
  - `src/apBoost/utils/apTypes.js` (lines 34-39) - `SESSION_STATUS.PAUSED` exists but is unused

- **Current Implementation:**
  - `beforeunload` only calls `e.preventDefault()` and sets `e.returnValue`
  - No Firestore update happens on browser close
  - Resume works because status stays `IN_PROGRESS`

- **Gap:** The PAUSED status was designed for explicit pauses. For browser close, IN_PROGRESS + resume is actually the correct flow. The spec may need clarification.

- **Dependencies:**
  - Changing to PAUSED would require updating InstructionScreen to check both statuses

### Fix Plan

#### Option A: Keep IN_PROGRESS for browser close (Recommended)
**Rationale:** Browser close without graceful cleanup should NOT change status to PAUSED because:
1. There's no guarantee `beforeunload` can complete an async Firestore write
2. IN_PROGRESS correctly indicates an incomplete session
3. Resume flow already works with IN_PROGRESS

**Action:** Document this as intentional design. No code changes needed.

#### Option B: Add PAUSED for explicit pause button (Future Enhancement)
If you want to support explicit pause:
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Add `pauseTest()` function
**Details:**
```javascript
const pauseTest = useCallback(async () => {
  if (!session?.id) return

  try {
    // Flush pending changes first
    if (queueLength > 0) {
      await flushQueue()
    }

    await updateSession(session.id, {
      status: SESSION_STATUS.PAUSED,
      sectionTimeRemaining: { [currentSection.id]: timer.timeRemaining }
    })

    timer.pause()
  } catch (err) {
    logError('useTestSession.pauseTest', { sessionId: session?.id }, err)
  }
}, [session?.id, queueLength, flushQueue, currentSection?.id, timer])
```

Then update InstructionScreen to check both statuses.

### Verification Steps
1. Start a test, close browser without using pause button
2. Reopen browser, navigate to test - verify resume screen appears with position info
3. Verify Firestore shows status as IN_PROGRESS (not PAUSED)

### Potential Risks
- None for Option A (no changes)
- Option B: Pausing mid-timer could cause sync issues with timer state

---

## Issue 3: beforeunload Warning Conditions (5.11)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criteria:** Page refresh / tab close shows beforeunload warning + resume
- **Current State:** Warning only appears when `queueLength > 0`, not always during active test.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useTestSession.js` (lines 208-220) - `handleBeforeUnload` only checks `queueLength`

- **Current Implementation:**
```javascript
const handleBeforeUnload = (e) => {
  if (queueLength > 0) {  // Only warns when queue has items
    e.preventDefault()
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
    return e.returnValue
  }
}
```

- **Gap:** If queue just flushed (queueLength === 0), user can close without warning even if they're in an active test.

- **Dependencies:** The `session` and `status` are available in the hook scope.

### Fix Plan

#### Step 1: Expand beforeunload condition
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Modify `handleBeforeUnload` at lines 210-216
**Details:**
- Warn if session exists AND status is IN_PROGRESS, regardless of queue length
- Keep the more specific message if queue has items

```javascript
const handleBeforeUnload = (e) => {
  // Warn if actively in test session
  if (session?.id && status === SESSION_STATUS.IN_PROGRESS) {
    e.preventDefault()
    const message = queueLength > 0
      ? 'You have unsaved changes. Are you sure you want to leave?'
      : 'You are in the middle of a test. Are you sure you want to leave?'
    e.returnValue = message
    return e.returnValue
  }
}
```

#### Step 2: Add status to dependency array
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Update useEffect dependency array at line 220
**Details:**
- Add `session?.id` and `status` to dependencies: `[queueLength, session?.id, status]`

### Verification Steps
1. Start a test, wait for queue to flush (queueLength = 0)
2. Try to close tab - verify warning appears
3. Start a test with some answers queued (queueLength > 0)
4. Try to close tab - verify warning shows "unsaved changes" message
5. Complete and submit test - verify no warning when closing

### Potential Risks
- **Risk:** False warnings if status check is stale
  - **Mitigation:** Status is kept in sync via session state, should be reliable

---

## Issue 4: QuotaExceededError Handling (5.12)

### Audit Finding
- **Status:** ❌ Missing
- **Criterion:** Device storage full -> Catch QuotaExceededError, try flush, show warning
- **Current State:** No QuotaExceededError handling in codebase. IndexedDB writes will fail with uncaught exception.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 140-148) - `addToQueue` uses try/catch but doesn't handle quota
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 143) - `store.add(queueItem)` can throw QuotaExceededError

- **Current Implementation:**
```javascript
try {
  const tx = dbRef.current.transaction(STORE_NAME, 'readwrite')
  const store = tx.objectStore(STORE_NAME)
  store.add(queueItem)  // Can throw QuotaExceededError
  // ... await transaction
} catch (error) {
  logError('useOfflineQueue.addToQueue', { sessionId, action }, error)
  // Error is logged but not handled differently for quota
}
```

- **Gap:** QuotaExceededError is not detected or handled. User gets no feedback, data may be lost.

- **Dependencies:**
  - Need a way to notify user (e.g., toast notification)
  - Need to expose `isStorageFull` state to UI

### Fix Plan

#### Step 1: Add storage full state
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add new state variable after line 54
**Details:**
```javascript
const [isStorageFull, setIsStorageFull] = useState(false)
```

#### Step 2: Handle QuotaExceededError in addToQueue
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Modify catch block at lines 157-159
**Details:**
```javascript
} catch (error) {
  logError('useOfflineQueue.addToQueue', { sessionId, action }, error)

  // Check for quota exceeded
  if (error.name === 'QuotaExceededError' ||
      error.message?.includes('quota') ||
      error.code === 22) {  // DOMException code for quota

    logDebug('useOfflineQueue.addToQueue', 'Storage quota exceeded, attempting flush')
    setIsStorageFull(true)

    // Try to flush to free up space
    if (isOnline) {
      try {
        await flushQueue()
        // Retry the add after flushing
        const retryTx = dbRef.current.transaction(STORE_NAME, 'readwrite')
        const retryStore = retryTx.objectStore(STORE_NAME)
        retryStore.add(queueItem)
        await new Promise((resolve, reject) => {
          retryTx.oncomplete = () => { setIsStorageFull(false); resolve() }
          retryTx.onerror = () => reject(retryTx.error)
        })
        await updateQueueLength()
        return // Success after retry
      } catch (retryError) {
        logError('useOfflineQueue.addToQueue', { sessionId }, retryError)
        // Still full after retry, user needs to know
      }
    }

    // Could not recover - throw to let UI know
    throw new Error('Storage full - please check your browser storage or go online to sync')
  }

  throw error  // Re-throw other errors
}
```

#### Step 3: Export isStorageFull state
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add to return object at line 277-283
**Details:**
```javascript
return {
  addToQueue,
  flushQueue,
  queueLength,
  isOnline,
  isFlushing,
  isStorageFull,  // Add this
}
```

#### Step 4: Pass isStorageFull to UI
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Destructure `isStorageFull` from useOfflineQueue at line 50
**Details:**
```javascript
const { addToQueue, flushQueue, queueLength, isOnline, isFlushing, isStorageFull } = useOfflineQueue(session?.id)
```

Add to return object around line 500.

#### Step 5: Display storage full warning in UI
**File:** `src/apBoost/components/ConnectionStatus.jsx`
**Action:** Add storage full banner
**Details:**
```javascript
// Add prop
export default function ConnectionStatus({ isConnected, isSyncing, isStorageFull }) {
  // Add new condition at the start
  if (isStorageFull) {
    return (
      <div className="bg-error border-b border-error-border px-4 py-2 flex items-center justify-center gap-2">
        <span className="text-error-text-strong">⚠</span>
        <span className="text-error-text-strong text-sm">
          Storage full - your answers may not be saved. Please submit your test soon.
        </span>
      </div>
    )
  }
  // ... rest of component
}
```

### Verification Steps
1. Fill IndexedDB storage with test data until near quota (browser devtools)
2. Start a test and answer questions
3. Verify storage full warning appears
4. Verify flush is attempted automatically
5. If online, verify retry succeeds after flush
6. If offline, verify user sees clear warning

### Potential Risks
- **Risk:** Different browsers have different quota error formats
  - **Mitigation:** Check multiple error properties (name, message, code)
- **Risk:** Infinite retry loop if flush fails
  - **Mitigation:** Only retry once, then throw

---

## Issue 5: Timer Expiry Auto-Submit (5.12)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Timer expires offline -> Queue auto-submit, complete on reconnect
- **Current State:** `handleTimerExpire` callback at useTestSession.js:136-140 only logs to console, doesn't trigger submission.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useTestSession.js` (lines 136-140) - Empty handler
  - `src/apBoost/hooks/useTimer.js` (lines 84-89) - Calls `onExpireRef.current()` when timer hits 0
  - `src/apBoost/hooks/useTestSession.js` (lines 396-421) - `submitTest()` function

- **Current Implementation:**
```javascript
const handleTimerExpire = useCallback(() => {
  // Auto-submit when timer expires
  console.log('Timer expired, auto-submitting...')
  // Could trigger auto-submit here  <-- Comment indicates incomplete
}, [])
```

- **Gap:** The handler does nothing. Timer expiry does not trigger submission.

- **Dependencies:**
  - `submitTest()` requires `frqData` for FRQ submission type
  - Offline submission needs to queue the action, not attempt immediate Firestore write
  - Need to handle case where user is on review screen vs testing screen

### Fix Plan

#### Step 1: Implement handleTimerExpire
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Replace lines 136-140
**Details:**
```javascript
const handleTimerExpire = useCallback(async () => {
  console.log('Timer expired, auto-submitting...')

  // Prevent multiple submissions
  if (isSubmitting) return

  // Queue the auto-submit action (works offline)
  addToQueue({
    action: 'AUTO_SUBMIT',
    payload: {
      reason: 'TIMER_EXPIRED',
      sectionIndex: currentSectionIndex,
      timestamp: Date.now()
    }
  })

  // If online, trigger actual submission
  // For FRQ sections, we default to typed submission on auto-submit
  if (isOnline) {
    try {
      const resultId = await submitTest({ frqSubmissionType: 'TYPED' })
      if (resultId) {
        // Navigation will be handled by the page component
      }
    } catch (err) {
      logError('useTestSession.handleTimerExpire', { sessionId: session?.id }, err)
      // Error will be handled, but we've queued the intent
    }
  }
}, [isSubmitting, addToQueue, currentSectionIndex, isOnline, submitTest, session?.id])
```

#### Step 2: Handle AUTO_SUBMIT action in queue flush
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add case in flushQueue switch statement at lines 203-224
**Details:**
```javascript
case 'AUTO_SUBMIT':
  // Mark that auto-submit was queued
  updates.autoSubmitQueued = {
    reason: item.payload.reason,
    timestamp: serverTimestamp()
  }
  break
```

#### Step 3: Check for pending auto-submit on reconnect
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Add effect to check for queued auto-submit
**Details:**
```javascript
// After line 206 (loadTestAndSession effect)
// Check for pending auto-submit when coming online
useEffect(() => {
  if (!session?.id || !isOnline || isSubmitting) return

  // Check if there's a pending auto-submit in Firestore
  // This would have been set during offline timer expiry
  if (session.autoSubmitQueued && !session.completedAt) {
    console.log('Found pending auto-submit, completing...')
    submitTest({ frqSubmissionType: 'TYPED' })
  }
}, [session?.id, session?.autoSubmitQueued, session?.completedAt, isOnline, isSubmitting, submitTest])
```

#### Step 4: Add dependencies to handleTimerExpire
**File:** `src/apBoost/hooks/useTestSession.js`
**Action:** Ensure callback has proper dependencies
**Details:**
- Dependencies: `[isSubmitting, addToQueue, currentSectionIndex, isOnline, submitTest, session?.id]`

### Verification Steps
1. Start a test with short timer (modify test data temporarily)
2. Wait for timer to expire online - verify auto-submit triggers
3. Start a test, go offline, wait for timer to expire
4. Come back online - verify submission completes
5. Check Firestore for `autoSubmitQueued` field on offline expiry

### Potential Risks
- **Risk:** User loses FRQ work if they were planning handwritten submission
  - **Mitigation:** For FRQ, could show warning 1 minute before expiry about submission type
- **Risk:** Race condition if user clicks submit while auto-submit triggers
  - **Mitigation:** `isSubmitting` check prevents duplicate submissions

---

## Issue 6: Local Timestamps for Queue Ordering (5.10)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Local timestamps for queue ordering only
- **Current State:** Timestamps are stored but never used for ordering or any purpose.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useOfflineQueue.js` (line 134) - `localTimestamp: Date.now()` stored
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 192-193) - Items filtered by status only, not sorted

- **Current Implementation:**
```javascript
const pendingItems = items.filter(item => item.status === 'PENDING')
// Not sorted by localTimestamp
```

- **Gap:** Items are processed in IndexedDB return order, not timestamp order. Could cause out-of-order application.

- **Dependencies:** This ties into Issue 1 (reconciliation) where timestamps ARE used for comparison.

### Fix Plan

#### Step 1: Sort queue items by localTimestamp before processing
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add sort after filter at line 193
**Details:**
```javascript
const pendingItems = items
  .filter(item => item.status === 'PENDING')
  .sort((a, b) => a.localTimestamp - b.localTimestamp)  // Oldest first
```

### Verification Steps
1. Queue multiple actions rapidly while offline
2. Come online, verify actions are applied in order
3. Check Firestore to ensure last answer overwrites earlier ones correctly

### Potential Risks
- Low risk change, just ensures deterministic ordering

---

## Issue 7: Extended Offline Warning (5.11)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** User offline entire test, never reconnects -> Data lost
- **Current State:** No warning for extended offline periods. Data stays in IndexedDB but user doesn't know it won't sync.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 85-104) - Online/offline listeners
  - `src/apBoost/components/ConnectionStatus.jsx` - Shows "Connection unstable" but not duration warning

- **Current Implementation:**
- Online/offline events update state immediately
- No tracking of how long user has been offline

- **Gap:** User may complete entire test offline without realizing data won't sync until they reconnect.

### Fix Plan

#### Step 1: Track offline duration
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add offline duration tracking
**Details:**
```javascript
// Add after line 54
const [offlineSince, setOfflineSince] = useState(null)
const [offlineDuration, setOfflineDuration] = useState(0)

// Modify handleOffline at line 93
const handleOffline = () => {
  setIsOnline(false)
  setOfflineSince(Date.now())
}

// Modify handleOnline at line 86
const handleOnline = () => {
  setIsOnline(true)
  setOfflineSince(null)
  setOfflineDuration(0)
  // ... rest of handler
}

// Add interval to track duration
useEffect(() => {
  if (!offlineSince) return

  const interval = setInterval(() => {
    setOfflineDuration(Date.now() - offlineSince)
  }, 10000)  // Update every 10 seconds

  return () => clearInterval(interval)
}, [offlineSince])
```

#### Step 2: Export offline duration
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add to return object
**Details:**
```javascript
return {
  // ... existing
  offlineDuration,  // milliseconds since going offline
}
```

#### Step 3: Show extended offline warning
**File:** `src/apBoost/components/ConnectionStatus.jsx`
**Action:** Add escalating warning based on duration
**Details:**
```javascript
export default function ConnectionStatus({ isConnected, isSyncing, isStorageFull, offlineDuration }) {
  // ... existing storage full check

  // Extended offline warning (after 5 minutes)
  const offlineMinutes = Math.floor((offlineDuration || 0) / 60000)

  if (!isConnected && offlineMinutes >= 5) {
    return (
      <div className="bg-error border-b border-error-border px-4 py-2 flex items-center justify-center gap-2">
        <span className="text-error-text-strong">⚠</span>
        <span className="text-error-text-strong text-sm">
          You've been offline for {offlineMinutes} minutes. Your answers are saved locally but won't sync until you reconnect.
        </span>
      </div>
    )
  }

  // ... rest of component
}
```

### Verification Steps
1. Start a test, go offline
2. Wait 5 minutes - verify warning appears and updates duration
3. Reconnect - verify warning disappears and data syncs

### Potential Risks
- **Risk:** Timer interval could be a minor performance concern
  - **Mitigation:** 10-second interval is reasonable, only runs when offline

---

## Issue 8: Firestore Quota Error Handling (5.12)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Firestore quota exceeded -> Exponential backoff, notify user
- **Current State:** Exponential backoff exists but quota-specific errors aren't distinguished.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 254-262) - Catch block with backoff
  - `src/apBoost/components/ConnectionStatus.jsx` - Shows generic unstable connection

- **Current Implementation:**
```javascript
} catch (error) {
  logError('useOfflineQueue.flushQueue', { sessionId }, error)

  // Exponential backoff retry
  retryCountRef.current++
  if (retryCountRef.current < 5) {
    const delay = Math.pow(2, retryCountRef.current) * 1000
    scheduleFlush(delay)
  }
}
```

All errors treated the same - no distinction for quota errors.

- **Gap:** User doesn't know if they're hitting Firestore quotas vs. network issues.

### Fix Plan

#### Step 1: Detect Firestore quota errors
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add quota error detection in flushQueue catch block
**Details:**
```javascript
// Add state after line 54
const [isQuotaExceeded, setIsQuotaExceeded] = useState(false)

// Modify catch block at line 254
} catch (error) {
  logError('useOfflineQueue.flushQueue', { sessionId }, error)

  // Check for Firestore quota errors
  const isQuotaError =
    error.code === 'resource-exhausted' ||
    error.message?.includes('quota') ||
    error.message?.includes('rate limit')

  if (isQuotaError) {
    setIsQuotaExceeded(true)
    logDebug('useOfflineQueue.flushQueue', 'Firestore quota exceeded')
  }

  // Exponential backoff retry
  retryCountRef.current++
  if (retryCountRef.current < 5) {
    const delay = Math.pow(2, retryCountRef.current) * 1000
    scheduleFlush(delay)
  }
}

// Clear quota error on success (around line 251)
setIsQuotaExceeded(false)
```

#### Step 2: Export and display quota warning
Similar pattern to storage full handling - add to return object, pass to ConnectionStatus, display specific message.

### Verification Steps
1. Difficult to test without hitting actual Firestore quotas
2. Could mock the error in development to verify UI handling

### Potential Risks
- Low risk - additive change only

---

## Issue 9: IndexedDB Transaction Error Handling (5.12)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Browser crash mid-IndexedDB write -> Atomic transaction rollback
- **Current State:** Transactions are used, but no explicit error handling for partial writes.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/hooks/useOfflineQueue.js` (lines 141-148) - Transaction handling

- **Current Implementation:**
```javascript
const tx = dbRef.current.transaction(STORE_NAME, 'readwrite')
const store = tx.objectStore(STORE_NAME)
store.add(queueItem)

await new Promise((resolve, reject) => {
  tx.oncomplete = resolve
  tx.onerror = () => reject(tx.error)
})
```

- **Gap:** IndexedDB handles atomicity natively, but we don't have recovery logic for corrupt data.

### Fix Plan

#### Step 1: Add onabort handler
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add abort handling to transactions
**Details:**
```javascript
await new Promise((resolve, reject) => {
  tx.oncomplete = resolve
  tx.onerror = () => reject(tx.error)
  tx.onabort = () => {
    logError('useOfflineQueue', { sessionId }, new Error('Transaction aborted'))
    reject(new Error('IndexedDB transaction aborted'))
  }
})
```

#### Step 2: Add database corruption recovery
**File:** `src/apBoost/hooks/useOfflineQueue.js`
**Action:** Add database reset capability
**Details:**
```javascript
// Add new function
const resetDatabase = useCallback(async () => {
  try {
    if (dbRef.current) {
      dbRef.current.close()
    }

    await new Promise((resolve, reject) => {
      const request = indexedDB.deleteDatabase(DB_NAME)
      request.onsuccess = resolve
      request.onerror = reject
    })

    dbRef.current = await openDatabase()
    await updateQueueLength()

    logDebug('useOfflineQueue.resetDatabase', 'Database reset successful')
  } catch (error) {
    logError('useOfflineQueue.resetDatabase', { sessionId }, error)
  }
}, [sessionId, updateQueueLength])
```

This provides a recovery path if database becomes corrupt.

### Verification Steps
1. Difficult to test without corrupting IndexedDB
2. Verify abort handler logs correctly in error scenarios

### Potential Risks
- **Risk:** Reset would lose pending data
  - **Mitigation:** Only expose reset as last resort, warn user

---

## Implementation Order

Recommended order to implement fixes (considering dependencies):

1. **Issue 4: QuotaExceededError Handling** - Quick win, prevents crashes, no dependencies
2. **Issue 6: Local Timestamps for Queue Ordering** - One-line change, improves reliability
3. **Issue 3: beforeunload Warning Conditions** - Small change, improves UX
4. **Issue 9: IndexedDB Transaction Error Handling** - Adds abort handler, low risk
5. **Issue 1: Queue Reconciliation on Resume** - Most critical for data integrity, depends on Items 4,6
6. **Issue 5: Timer Expiry Auto-Submit** - User-facing impact, requires tested queue
7. **Issue 7: Extended Offline Warning** - UX improvement
8. **Issue 8: Firestore Quota Error Handling** - Nice to have
9. **Issue 2: PAUSED Status** - Optional, current behavior is acceptable

---

## Cross-Cutting Concerns

### Timestamp Handling Utility
Create a utility for comparing Firestore timestamps with local timestamps:

**File:** `src/apBoost/utils/timestampUtils.js`
```javascript
/**
 * Convert various timestamp formats to milliseconds
 */
export function toMillis(timestamp) {
  if (!timestamp) return 0

  // Firestore Timestamp object
  if (typeof timestamp.toMillis === 'function') {
    return timestamp.toMillis()
  }

  // Firestore Timestamp-like object { seconds, nanoseconds }
  if (timestamp.seconds != null) {
    return timestamp.seconds * 1000 + Math.floor((timestamp.nanoseconds || 0) / 1000000)
  }

  // Regular number (already milliseconds)
  if (typeof timestamp === 'number') {
    return timestamp
  }

  // Date object
  if (timestamp instanceof Date) {
    return timestamp.getTime()
  }

  return 0
}

/**
 * Compare two timestamps with a buffer for clock drift
 * @returns negative if a < b, positive if a > b, 0 if within buffer
 */
export function compareTimestamps(a, b, bufferMs = 1000) {
  const aMs = toMillis(a)
  const bMs = toMillis(b)
  const diff = aMs - bMs

  if (Math.abs(diff) <= bufferMs) return 0
  return diff
}
```

### Error Classification Utility
Create a utility for classifying errors:

**File:** `src/apBoost/utils/errorUtils.js`
```javascript
export function isQuotaError(error) {
  return (
    error?.name === 'QuotaExceededError' ||
    error?.code === 22 ||  // DOMException quota code
    error?.code === 'resource-exhausted' ||  // Firestore
    error?.message?.toLowerCase().includes('quota') ||
    error?.message?.toLowerCase().includes('storage')
  )
}

export function isNetworkError(error) {
  return (
    error?.code === 'unavailable' ||
    error?.message?.toLowerCase().includes('network') ||
    error?.message?.toLowerCase().includes('offline') ||
    !navigator.onLine
  )
}
```

---

## Notes for Implementer

1. **Testing Queue Reconciliation:** The most complex fix. Set up a test scenario:
   - Open test in browser A, answer some questions
   - Kill browser A (task manager, not close)
   - Open test in browser B, answer same questions differently
   - Restore browser A, verify reconciliation works

2. **Firestore Timestamps:** When reading from Firestore, `serverTimestamp()` resolves to a Timestamp object. But when first written, it may be a sentinel. Always handle both.

3. **IndexedDB in Incognito:** IndexedDB may have limited space or behave differently in incognito. The QuotaExceededError handling becomes more important.

4. **Mobile Browsers:** Safari and mobile browsers have stricter storage quotas. Test on mobile before release.

5. **Error Boundaries:** The `APErrorBoundary` will catch render errors but not async errors. Ensure async errors are handled with try/catch.

6. **User Communication:** All new warnings should follow the existing pattern in `ConnectionStatus.jsx` using semantic color tokens (`bg-warning`, `bg-error`, etc.).

---

## Part 2: Codebase Facts

# CODEBASE_FACTS__UNK__5.9_to_5.12

**Generated:** 2026-01-14
**Chunk Scope:** Offline queue persistence, session resume reconciliation, timer expiry, lifecycle events, quota handling, extended offline tracking

---

## Section 1: Canonical Data Schema / Source-of-Truth

**Found: Yes**

### Firestore Session Document Schema

**Collection:** `ap_session_state` (defined in `src/apBoost/utils/apTypes.js:94`)

**Evidence:** `src/apBoost/services/apSessionService.js` lines 47-67

```javascript
const sessionData = {
  userId,
  testId,
  assignmentId,
  sessionToken: generateSessionToken(),
  status: SESSION_STATUS.IN_PROGRESS,
  attemptNumber,
  currentSectionIndex: 0,
  currentQuestionIndex: 0,
  sectionTimeRemaining: {},
  answers: {},
  flaggedQuestions: [],
  annotations: {},
  strikethroughs: {},
  lastHeartbeat: serverTimestamp(),
  lastAction: serverTimestamp(),
  startedAt: serverTimestamp(),
  completedAt: null,
}
```

**Fields relevant to resume/timer/submission:**

| Field | Type | Purpose | Written Where |
|-------|------|---------|---------------|
| `status` | string | `IN_PROGRESS`, `PAUSED`, `COMPLETED`, `NOT_STARTED` | apSessionService.js:54, 225 |
| `lastAction` | serverTimestamp | Last user action timestamp | apSessionService.js:64, 116, 135, 171, 190, 209, 227 |
| `lastHeartbeat` | serverTimestamp | Last heartbeat ping | apSessionService.js:63, 261; useHeartbeat.js:56; useDuplicateTabGuard.js:35 |
| `sectionTimeRemaining` | object | Map of sectionId → seconds remaining | apSessionService.js:58, 208; useOfflineQueue.js:218 |
| `completedAt` | timestamp/null | When session was submitted | apSessionService.js:66, 226 |
| `sessionToken` | string | Unique tab identifier for duplicate detection | apSessionService.js:53; useHeartbeat.js:57; useDuplicateTabGuard.js:34 |

**SESSION_STATUS Constants:** `src/apBoost/utils/apTypes.js` lines 33-39
```javascript
export const SESSION_STATUS = {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  PAUSED: 'PAUSED',
  COMPLETED: 'COMPLETED',
}
```

**Note:** `autoSubmitQueued` field does **NOT EXIST** in the current schema. Fix plans propose adding it.

### Firestore Collections

**Evidence:** `src/apBoost/utils/apTypes.js` lines 89-98
```javascript
export const COLLECTIONS = {
  TESTS: 'ap_tests',
  QUESTIONS: 'ap_questions',
  STIMULI: 'ap_stimuli',
  SESSION_STATE: 'ap_session_state',
  TEST_RESULTS: 'ap_test_results',
  CLASSES: 'ap_classes',
  ASSIGNMENTS: 'ap_assignments',
}
```

### Session Fields Read into UI/Hooks

**Evidence:** `src/apBoost/hooks/useTestSession.js` lines 176-195
```javascript
if (existingSession) {
  setSession(existingSession)
  setCurrentSectionIndex(existingSession.currentSectionIndex || 0)
  setCurrentQuestionIndex(existingSession.currentQuestionIndex || 0)
  // Restore answers
  const answersMap = new Map()
  if (existingSession.answers) {
    Object.entries(existingSession.answers).forEach(([qId, ans]) => {
      answersMap.set(qId, ans)
    })
  }
  setAnswers(answersMap)
  // Restore flags
  const flagsSet = new Set(existingSession.flaggedQuestions || [])
  setFlags(flagsSet)
}
```

---

## Section 2: Write Paths

**Found: Yes**

### Path 1: Queued Writes via IndexedDB (Primary Path)

**Entry:** `useOfflineQueue.addToQueue()`
**File:** `src/apBoost/hooks/useOfflineQueue.js` lines 125-160

**Queue Actions Supported:**
| Action | Payload | Firestore Update |
|--------|---------|------------------|
| `ANSWER_CHANGE` | `{ questionId, value }` | `answers.${questionId}` |
| `FLAG_TOGGLE` | `{ questionId, markedForReview }` | Comment says "needs special handling" - NOT actually applied |
| `NAVIGATION` | `{ currentSectionIndex, currentQuestionIndex }` | `currentSectionIndex`, `currentQuestionIndex` |
| `TIMER_SYNC` | `{ sectionTimeRemaining: { sectionId: time } }` | `sectionTimeRemaining.${sectionId}` |

**Flush Mechanism:**
- `flushQueue()` at lines 173-266
- Uses single `updateDoc()` - NOT batched writes or transactions
- Idempotency: Items deleted by `store.delete(item.id)` after successful flush (line 243)
- **Hazard:** FLAG_TOGGLE is queued but never processed in switch statement (line 209-210 is a comment only)

**Evidence - flushQueue implementation:** lines 201-236
```javascript
const updates = {}
for (const item of pendingItems) {
  switch (item.action) {
    case 'ANSWER_CHANGE':
      updates[`answers.${item.payload.questionId}`] = item.payload.value
      break
    case 'FLAG_TOGGLE':
      // Flags need special handling - we'd need to maintain the array
      break
    case 'NAVIGATION':
      updates.currentSectionIndex = item.payload.currentSectionIndex
      updates.currentQuestionIndex = item.payload.currentQuestionIndex
      break
    case 'TIMER_SYNC':
      // ...
      break
  }
}
if (Object.keys(updates).length > 0) {
  updates.lastAction = serverTimestamp()
  await withTimeout(
    updateDoc(doc(db, COLLECTIONS.SESSION_STATE, sessionId), updates),
    TIMEOUTS.FIRESTORE_WRITE,
    'Queue flush'
  )
}
```

### Path 2: Direct Firestore Writes (Bypass Queue)

**Files and Functions:**

| Service Function | File:Lines | Firestore Method |
|-----------------|------------|------------------|
| `createOrResumeSession()` | apSessionService.js:30-76 | `setDoc()` |
| `updateSession()` | apSessionService.js:112-122 | `updateDoc()` |
| `saveAnswer()` | apSessionService.js:131-141 | `updateDoc()` |
| `toggleQuestionFlag()` | apSessionService.js:150-176 | `getDoc()` + `updateDoc()` (read-modify-write) |
| `updatePosition()` | apSessionService.js:185-196 | `updateDoc()` |
| `updateTimer()` | apSessionService.js:205-215 | `updateDoc()` |
| `completeSession()` | apSessionService.js:222-233 | `updateDoc()` |
| `updateHeartbeat()` | apSessionService.js:258-267 | `updateDoc()` |

**Important:** These direct service functions are **NOT CALLED** during normal test session. The imports exist in `useTestSession.js` lines 4-11 but are only used for:
- Initial session creation (`createOrResumeSession` at line 228)
- Flag service imports exist but not used (queue handles flags locally)

### Path 3: Submission Pipeline

**Entry:** `useTestSession.submitTest()` at lines 396-421

**Evidence:**
```javascript
const submitTest = useCallback(async (frqData = null) => {
  if (!session?.id || isSubmitting) return null
  try {
    setIsSubmitting(true)
    timer.pause()
    // Flush any pending changes first
    if (queueLength > 0) {
      await flushQueue()
    }
    const resultId = await createTestResult(session.id, frqData)
    return resultId
  } catch (err) { ... }
}, [session?.id, isSubmitting, timer, queueLength, flushQueue])
```

- **Flush-before-submit:** Yes, queue is flushed before creating result
- **Scoring service:** `createTestResult()` in `apScoringService.js:67-166` calls `completeSession()` to mark status

---

## Section 3: Offline/Resilience Mechanics

**Found: Partial (significant gaps)**

### IndexedDB Configuration

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 8-11, 16-37

```javascript
const DB_NAME = 'ap_boost_queue'
const STORE_NAME = 'actions'
const DB_VERSION = 1

function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION)
    // ...
    request.onupgradeneeded = (event) => {
      const db = event.target.result
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' })
        store.createIndex('sessionId', 'sessionId', { unique: false })
        store.createIndex('status', 'status', { unique: false })
      }
    }
  })
}
```

| Property | Value |
|----------|-------|
| Database Name | `ap_boost_queue` |
| Store Name | `actions` |
| Key Path | `id` |
| Indexes | `sessionId` (non-unique), `status` (non-unique) |

### Queue Item Schema

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 131-138

```javascript
const queueItem = {
  id: generateId(),           // `${Date.now()}-${random}`
  sessionId,
  localTimestamp: Date.now(),
  action: action.action,      // 'ANSWER_CHANGE' | 'FLAG_TOGGLE' | 'NAVIGATION' | 'TIMER_SYNC'
  payload: action.payload,
  status: 'PENDING',
}
```

| Field | Type | Purpose |
|-------|------|---------|
| `id` | string | Unique identifier, used as keyPath |
| `sessionId` | string | Foreign key to session |
| `localTimestamp` | number | `Date.now()` when queued |
| `action` | string | Action type enum |
| `payload` | object | Action-specific data |
| `status` | string | Always 'PENDING' (no other status used) |

### Queue Lifecycle

- **Created:** `addToQueue()` sets status to `'PENDING'`
- **Flushed:** `flushQueue()` filters for `status === 'PENDING'` then deletes items by `id`
- **No intermediate states:** Status never changes to 'APPLIED' or similar - items are deleted after flush

### Ordering Guarantees

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 181-192

```javascript
const index = store.index('sessionId')
const request = index.getAll(IDBKeyRange.only(sessionId))
// ...
const pendingItems = items.filter(item => item.status === 'PENDING')
```

- **Order:** Items retrieved via `index.getAll()` - IndexedDB returns in insertion order by default
- **No explicit sort by localTimestamp** in flushQueue
- **Processing:** All pending items are merged into a single update object (last-write-wins within batch)

### Retry/Backoff Behavior

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 254-262

```javascript
} catch (error) {
  logError('useOfflineQueue.flushQueue', { sessionId }, error)
  // Exponential backoff retry
  retryCountRef.current++
  if (retryCountRef.current < 5) {
    const delay = Math.pow(2, retryCountRef.current) * 1000 // 2s, 4s, 8s, 16s
    scheduleFlush(delay)
  }
}
```

| Retry | Delay |
|-------|-------|
| 1 | 2s |
| 2 | 4s |
| 3 | 8s |
| 4 | 16s |
| 5+ | **Stops retrying** |

**Triggers for flush:**
- `online` event (lines 86-91)
- After `addToQueue()` if online (lines 153-156) - 1s debounce
- No visibilitychange trigger in useOfflineQueue

### Lifecycle Events

| Event | File:Lines | Behavior |
|-------|------------|----------|
| `beforeunload` | useTestSession.js:209-220 | Shows warning if `queueLength > 0` |
| `beforeunload` | useDuplicateTabGuard.js:115-126 | Empty handler (comment says don't clear token) |
| `visibilitychange` | useHeartbeat.js:101-113 | Triggers heartbeat when tab becomes visible |
| `online` | useOfflineQueue.js:86-91 | Resets retry count, schedules flush |
| `offline` | useOfflineQueue.js:93-95 | Sets `isOnline` to false |
| `pagehide` | — | **NOT FOUND** |

**Evidence - beforeunload in useTestSession:**
```javascript
useEffect(() => {
  const handleBeforeUnload = (e) => {
    if (queueLength > 0) {
      e.preventDefault()
      e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
      return e.returnValue
    }
  }
  window.addEventListener('beforeunload', handleBeforeUnload)
  return () => window.removeEventListener('beforeunload', handleBeforeUnload)
}, [queueLength])
```

### Reconciliation on Resume

**NOT FOUND**

- `loadTestAndSession()` in useTestSession.js:161-206 loads Firestore session
- `useOfflineQueue` initializes and counts queue items (`updateQueueLength()`)
- **No comparison of `localTimestamp` vs `session.lastAction`**
- **No discard of stale queue items**

**Evidence of absence:** The `updateQueueLength` function only counts items:
```javascript
const updateQueueLength = useCallback(async () => {
  // ...
  const index = store.index('sessionId')
  const request = index.count(IDBKeyRange.only(sessionId))
  request.onsuccess = () => {
    setQueueLength(request.result)
  }
}, [sessionId])
```

### Quota Handling

**IndexedDB QuotaExceededError: NOT FOUND**

- `addToQueue()` has try/catch but no specific quota detection (lines 140-159)
- No `error.name === 'QuotaExceededError'` check
- No `error.code === 22` check

**Firestore resource-exhausted: NOT FOUND**

- `flushQueue()` catch block doesn't distinguish quota errors
- All errors treated the same - exponential backoff applied

### Extended Offline Duration Tracking

**NOT FOUND**

- No `offlineSince` state variable
- No `offlineDuration` tracking
- No UI escalation for extended offline periods

### IndexedDB Transaction Abort Handling

**NOT FOUND**

- No explicit transaction abort handlers
- No `resetDatabase()` function exists

---

## Section 4: UI/Flow Entry Points

**Found: Yes**

### ConnectionStatus Component

**File:** `src/apBoost/components/ConnectionStatus.jsx` (50 lines)

**Props:**
```javascript
export default function ConnectionStatus({ isConnected, isSyncing })
```

**States Displayed:**

| Condition | UI |
|-----------|-----|
| `isConnected && !isSyncing` | Returns `null` (hidden) |
| `isSyncing` | Blue info banner: "Syncing your progress..." with spinner |
| `!isConnected` | Yellow warning banner: "Connection unstable - your progress is being saved locally" |

**Props NOT currently supported:**
- `isStorageFull` - **NOT FOUND**
- `offlineDuration` - **NOT FOUND**
- `isQuotaExceeded` - **NOT FOUND**

**Usage in APTestSession.jsx:**
```javascript
<ConnectionStatus isConnected={isConnected} isSyncing={isSyncing} />
```

### DuplicateTabModal

**File:** `src/apBoost/components/DuplicateTabModal.jsx` (53 lines)

**Props:**
```javascript
export default function DuplicateTabModal({ onTakeControl, onGoToDashboard })
```

- Renders when `isInvalidated` is true in APTestSession.jsx (lines 362-367, 394-400)
- Modal with two buttons: "Go to Dashboard" and "Use This Tab"

### InstructionScreen

**File:** `src/apBoost/components/InstructionScreen.jsx` (94 lines)

**Props:**
```javascript
export default function InstructionScreen({ test, assignment, existingSession, onBegin, onCancel })
```

**Resume Detection:** line 19
```javascript
const isResuming = existingSession?.status === SESSION_STATUS.IN_PROGRESS
```

**Resume UI:** lines 66-73
```javascript
{isResuming && existingSession && (
  <div className="bg-info rounded-[--radius-alert] p-4 mb-6">
    <p className="text-info-text-strong text-sm">
      Resume from: Section {existingSession.currentSectionIndex + 1},
      Question {existingSession.currentQuestionIndex + 1}
    </p>
  </div>
)}
```

### View State Machine in APTestSession

**File:** `src/apBoost/pages/APTestSession.jsx` lines 44-45

```javascript
// View state: 'instruction' | 'testing' | 'review' | 'frqChoice' | 'frqHandwritten'
const [view, setView] = useState('instruction')
```

---

## Section 5: Must-Answer Questions

### Q1: Canonical Firestore session doc schema for timing + resume

**Found: Yes**

**Evidence:** `src/apBoost/services/apSessionService.js` lines 47-67

Fields:
- `status`: SESSION_STATUS enum (line 54)
- `lastAction`: serverTimestamp (line 64)
- `lastHeartbeat`: serverTimestamp (line 63)
- `sectionTimeRemaining`: object map (line 58)
- `completedAt`: null/serverTimestamp (line 66)
- `startedAt`: serverTimestamp (line 65)

**`autoSubmitQueued` does NOT EXIST** in current implementation.

---

### Q2: IndexedDB queue item schema

**Found: Yes**

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 131-138

```javascript
const queueItem = {
  id: generateId(),
  sessionId,
  localTimestamp: Date.now(),
  action: action.action,
  payload: action.payload,
  status: 'PENDING',
}
```

**Indexes:** `sessionId` (non-unique), `status` (non-unique) - lines 32-33

---

### Q3: Reconciliation logic on session resume

**Found: No**

- `loadTestAndSession()` at useTestSession.js:161-206 loads Firestore state
- `updateQueueLength()` at useOfflineQueue.js:107-122 only counts items
- **No comparison of `localTimestamp` vs `session.lastAction`**
- **No stale item discard logic exists**

---

### Q4: Queue as only write path vs bypass

**Found: Mixed**

**Queued writes (primary path):**
- ANSWER_CHANGE, NAVIGATION, TIMER_SYNC via `addToQueue()`

**Direct writes (bypass queue):**
- Session creation: `createOrResumeSession()` uses `setDoc()`
- Session completion: `completeSession()` uses `updateDoc()`
- Heartbeat: `useHeartbeat.doHeartbeat()` uses `updateDoc()`
- Duplicate tab claim: `useDuplicateTabGuard.claimSession()` uses `updateDoc()`

---

### Q5: flushQueue implementation

**Found: Yes**

**Evidence:** `src/apBoost/hooks/useOfflineQueue.js` lines 173-266

- **Method:** Single `updateDoc()` call (line 232)
- **No batch/transaction** used
- **Idempotency:** Items deleted by `id` after success (line 243)
- **Duplicate hazard:** If flush fails mid-write and retries, same updates are re-applied (safe for last-write-wins fields)

---

### Q6: flushQueue triggers

**Found: Yes**

| Trigger | Location | Condition |
|---------|----------|-----------|
| `online` event | useOfflineQueue.js:90 | `scheduleFlush(1000)` |
| After `addToQueue()` | useOfflineQueue.js:154-156 | If `isOnline` |
| Debounced timeout | useOfflineQueue.js:163-170 | Via `scheduleFlush(delay)` |

**Backoff logic:** Yes, lines 257-262 - exponential with max 5 retries

**Retry state:** Stored in `retryCountRef.current`

---

### Q7: Timer implementation

**Found: Yes**

**Evidence:** `src/apBoost/hooks/useTimer.js`

- **Tick-based:** 1 second interval (line 95: `setInterval(..., 1000)`)
- **State:** `timeRemaining` decremented each tick (line 77)
- **Pause/Resume:** `isRunning` state + `isPaused` prop control (lines 67, 47-49, 52-56)
- **Authoritative source:** `initialTime` from session's `sectionTimeRemaining` or section's `timeLimit * 60`

**Evidence of initialTime:** useTestSession.js:127-134
```javascript
const initialTime = useMemo(() => {
  if (!currentSection) return 0
  const savedTime = session?.sectionTimeRemaining?.[currentSection.id]
  if (savedTime != null) return savedTime
  return (currentSection.timeLimit || 45) * 60
}, [currentSection, session])
```

---

### Q8: Lifecycle events beyond beforeunload

**Found: Partial**

| Event | Handler Location | Behavior |
|-------|-----------------|----------|
| `beforeunload` | useTestSession.js:209-220 | Warns if queue not empty |
| `beforeunload` | useDuplicateTabGuard.js:115-126 | Empty (intentionally) |
| `visibilitychange` | useHeartbeat.js:101-113 | Triggers heartbeat on visible |
| `pagehide` | — | **NOT FOUND** |

**visibilitychange in useHeartbeat:**
```javascript
const handleVisibilityChange = () => {
  if (document.visibilityState === 'visible' && sessionId && instanceToken) {
    doHeartbeat()
  }
}
document.addEventListener('visibilitychange', handleVisibilityChange)
```

**Note:** visibilitychange does NOT trigger queue flush - only heartbeat.

---

### Q9: Auto-submit on timer expiry

**Found: Placeholder only**

**Evidence:** `src/apBoost/hooks/useTestSession.js` lines 136-140

```javascript
const handleTimerExpire = useCallback(() => {
  // Auto-submit when timer expires
  console.log('Timer expired, auto-submitting...')
  // Could trigger auto-submit here
}, [])
```

- **Only logs to console** - no actual submission triggered
- **No queue action** for offline timer expiry
- Handler is passed to useTimer (line 154: `onExpire: handleTimerExpire`)

---

### Q10: ConnectionStatus UI states

**Found: Yes**

**Evidence:** `src/apBoost/components/ConnectionStatus.jsx`

**Props accepted:** `isConnected`, `isSyncing`

**States displayed:**
1. Hidden (null) when connected and not syncing
2. "Syncing your progress..." (blue info banner)
3. "Connection unstable - your progress is being saved locally" (yellow warning)

**NOT supported:**
- Storage full warning
- Quota exceeded warning
- Extended offline duration indicator

---

### Q11: Timestamp conversion / error classification utilities

**Found: Partial**

**Timeout utility exists:** `src/apBoost/utils/withTimeout.js`
```javascript
export const TIMEOUTS = {
  FIRESTORE_READ: 10000,
  FIRESTORE_WRITE: 15000,
  SESSION_LOAD: 20000,
  HEARTBEAT: 5000,
  QUEUE_FLUSH: 30000,
}
```

**`toMillis` utility:** **NOT FOUND** (only proposed in fix plans)

**Quota error classification:** **NOT FOUND**
- No `error.name === 'QuotaExceededError'` check
- No `error.code === 'resource-exhausted'` check

---

### Q12: Tests for offline queue, resume, flush ordering, timer expiry, beforeunload, quota errors

**Found: No**

- No test files found in `src/apBoost/`
- No `*.test.js`, `*.spec.js`, or `__tests__` directories
- Only test files in project are in `node_modules/`

---

## Summary of Gaps

| Feature | Status | Location |
|---------|--------|----------|
| Queue reconciliation on resume | ❌ Not implemented | useOfflineQueue.js |
| localTimestamp comparison | ❌ Stored but unused | useOfflineQueue.js:134 |
| Timer auto-submit | ❌ Placeholder only | useTestSession.js:136-140 |
| AUTO_SUBMIT queue action | ❌ Not handled | useOfflineQueue.js:204 |
| visibilitychange queue flush | ❌ Not implemented | useOfflineQueue.js |
| pagehide handler | ❌ Not implemented | — |
| QuotaExceededError handling | ❌ Not implemented | useOfflineQueue.js |
| resource-exhausted classification | ❌ Not implemented | useOfflineQueue.js |
| Extended offline duration tracking | ❌ Not implemented | — |
| IndexedDB transaction abort handling | ❌ Not implemented | — |
| resetDatabase utility | ❌ Not implemented | — |
| toMillis utility | ❌ Not implemented | — |
| Unit/integration tests | ❌ None found | src/apBoost/ |
| FLAG_TOGGLE in flush | ❌ Queued but not processed | useOfflineQueue.js:209-210 |
