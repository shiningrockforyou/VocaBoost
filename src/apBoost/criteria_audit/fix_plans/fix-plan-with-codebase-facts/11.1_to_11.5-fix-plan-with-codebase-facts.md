# Section 11.1 to 11.5 - Fix Plan with Codebase Facts

> **What is this file?**
> This document combines two resources for implementing criteria section 11.1 to 11.5:
> 1. **Fix Plan** - Step-by-step implementation instructions for code changes
> 2. **Codebase Facts** - Relevant code snippets, file paths, and existing patterns from the codebase
>
> Use the Fix Plan as your guide and reference the Codebase Facts for accurate file locations and code context.

---

## Part 1: Fix Plan

# Fix Plan: Sections 11.1 to 11.5

**Planned by:** Claude Agent
**Date:** 2026-01-14
**Status:** COMPLETE
**Based on Audit:** section_11.1_to_11.5_criteria_audit.md

## Executive Summary
- Total Issues: 6
- ⚠️ Partial Implementations: 4
- ❌ Missing Features: 2
- ❓ Needs Investigation: 0
- Estimated Complexity: Medium-High

---

## Issue 1: Question Drag-to-Reorder (MISSING)

### Audit Finding
- **Status:** ❌ Missing
- **Criterion:** Question list - Drag to reorder questions within sections
- **Current State:** No drag-and-drop or move buttons implemented for questions within sections. `reorderSectionQuestions` is imported but never used.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/pages/APTestEditor.jsx` (lines 111-139) - Question list rendering
  - `src/apBoost/pages/APTestEditor.jsx` (line 6) - Imports `reorderSectionQuestions` but never uses it
  - `src/apBoost/services/apQuestionService.js` (lines 317-346) - `reorderSectionQuestions` function exists and is fully implemented
- **Current Implementation:**
  - Questions are displayed in a list with Edit/Remove buttons only
  - The Firestore update function `reorderSectionQuestions(testId, sectionIndex, newOrder)` is ready to use
  - Sections have move buttons (up/down) but questions do not
- **Gap:** No UI controls for reordering questions
- **Dependencies:** Section ordering is working with buttons, can follow same pattern

### Fix Plan

#### Step 1: Add question move handlers to APTestEditor
**File:** `src/apBoost/pages/APTestEditor.jsx`
**Action:** Modify
**Details:**
- Add a new function `handleMoveQuestion(sectionIndex, fromIndex, toIndex)` similar to `handleMoveSection`
- The function should:
  1. Get current section's questionIds array
  2. Swap or reorder the elements
  3. Update local state via `setSections`
  4. If not a new test, call `reorderSectionQuestions(testId, sectionIndex, newOrder)` to persist

```javascript
// Add after handleMoveSection (around line 304)
const handleMoveQuestion = async (sectionIndex, questionIndex, direction) => {
  const section = sections[sectionIndex]
  const questionIds = [...(section.questionIds || [])]
  const newIndex = direction === 'up' ? questionIndex - 1 : questionIndex + 1

  if (newIndex < 0 || newIndex >= questionIds.length) return

  // Swap
  const temp = questionIds[questionIndex]
  questionIds[questionIndex] = questionIds[newIndex]
  questionIds[newIndex] = temp

  // Update local state
  const newSections = [...sections]
  newSections[sectionIndex] = { ...section, questionIds }
  setSections(newSections)

  // Persist if existing test
  if (!isNew && testId) {
    try {
      await reorderSectionQuestions(testId, sectionIndex, questionIds)
    } catch (err) {
      logError('APTestEditor.moveQuestion', { testId, sectionIndex, questionIndex }, err)
    }
  }
}
```

#### Step 2: Add move buttons to question list UI
**File:** `src/apBoost/pages/APTestEditor.jsx`
**Action:** Modify
**Details:**
- Modify the question list in SectionEditor (lines 111-139)
- Pass `onMoveQuestion` prop to SectionEditor
- Add up/down buttons similar to section move buttons

```jsx
// Update question list item (around lines 111-139)
{questions.map((question, idx) => (
  <div
    key={question.id}
    className="flex items-center justify-between py-2 px-3 bg-muted rounded-[--radius-sm]"
  >
    <div className="flex-1 min-w-0">
      <span className="text-text-muted text-sm mr-2">{idx + 1}.</span>
      <span className="text-text-primary text-sm truncate">
        {question.questionText?.substring(0, 60)}
        {question.questionText?.length > 60 ? '...' : ''}
      </span>
    </div>
    <div className="flex items-center gap-2 ml-2">
      {/* Add move buttons */}
      <button
        onClick={() => onMoveQuestion(idx, 'up')}
        disabled={idx === 0}
        className="p-1 text-text-muted hover:text-text-primary disabled:opacity-30"
        title="Move up"
      >
        <span className="text-sm">^</span>
      </button>
      <button
        onClick={() => onMoveQuestion(idx, 'down')}
        disabled={idx === questions.length - 1}
        className="p-1 text-text-muted hover:text-text-primary disabled:opacity-30"
        title="Move down"
      >
        <span className="text-sm">v</span>
      </button>
      <Link
        to={`/ap/teacher/question/${question.id}/edit`}
        className="text-brand-primary text-xs hover:underline"
      >
        Edit
      </Link>
      <button
        onClick={() => onRemoveQuestion(question.id)}
        className="text-error-text text-xs hover:underline"
      >
        Remove
      </button>
    </div>
  </div>
))}
```

#### Step 3: Update SectionEditor props
**File:** `src/apBoost/pages/APTestEditor.jsx`
**Action:** Modify
**Details:**
- Add `onMoveQuestion` to SectionEditor props (line 14)
- Pass the handler when rendering SectionEditor (around line 480)

### Verification Steps
1. Create a test with a section containing 3+ questions
2. Use up/down buttons to reorder questions
3. Verify order persists after page reload
4. Check that first question's up button is disabled
5. Check that last question's down button is disabled

### Potential Risks
- Race condition if user clicks rapidly - mitigate with debounce or disable during async operation
- Need to ensure questionsCache stays in sync after reorder

---

## Issue 2: Section Drag-to-Reorder (PARTIAL)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Section management - Drag to reorder sections
- **Current State:** Uses up/down buttons (^ and v) instead of true drag-and-drop. Functionally equivalent but not matching "drag" requirement.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/pages/APTestEditor.jsx` (lines 42-57) - Section move buttons
  - `src/apBoost/pages/APTestEditor.jsx` (lines 294-304) - `handleMoveSection` function
  - `package.json` - No drag-and-drop library currently installed
- **Current Implementation:** Up/down buttons that swap adjacent sections
- **Gap:** No drag-and-drop gesture support
- **Dependencies:** Would require adding a DnD library like `@dnd-kit/core` or `react-beautiful-dnd`

### Fix Plan

#### Option A: Keep Buttons (Recommended for MVP)
The current button-based implementation is functional and accessible. Consider accepting this as meeting the functional requirement while not matching the exact UX specification.

**Justification:**
- Buttons are more accessible (keyboard-friendly)
- No additional dependencies required
- Current implementation already works correctly
- Drag-and-drop can be added in a future enhancement

#### Option B: Add True Drag-and-Drop

#### Step 1: Install drag-and-drop library
**File:** `package.json`
**Action:** Add dependency
**Details:**
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

Chose `@dnd-kit` over `react-beautiful-dnd` because:
- Better React 18/19 support
- Smaller bundle size
- More flexible API
- Better maintained

#### Step 2: Create DraggableSectionList component
**File:** `src/apBoost/components/teacher/DraggableSectionList.jsx` (NEW)
**Action:** Create
**Details:**
- Wrap sections in DndContext from @dnd-kit/core
- Use SortableContext and useSortable hook
- Implement DragHandle component
- Call `onReorder` callback when drag ends

```jsx
import { DndContext, closestCenter } from '@dnd-kit/core'
import { SortableContext, verticalListSortingStrategy, useSortable } from '@dnd-kit/sortable'
import { CSS } from '@dnd-kit/utilities'

function SortableSectionItem({ section, id, children }) {
  const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id })

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  }

  return (
    <div ref={setNodeRef} style={style}>
      <div {...attributes} {...listeners} className="cursor-grab">
        {/* Drag handle */}
        <span className="text-text-muted">⋮⋮</span>
      </div>
      {children}
    </div>
  )
}

export default function DraggableSectionList({ sections, onReorder, renderSection }) {
  const handleDragEnd = (event) => {
    const { active, over } = event
    if (active.id !== over?.id) {
      const oldIndex = sections.findIndex((_, i) => `section-${i}` === active.id)
      const newIndex = sections.findIndex((_, i) => `section-${i}` === over.id)
      onReorder(oldIndex, newIndex)
    }
  }

  return (
    <DndContext collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
      <SortableContext items={sections.map((_, i) => `section-${i}`)} strategy={verticalListSortingStrategy}>
        {sections.map((section, index) => (
          <SortableSectionItem key={index} id={`section-${index}`} section={section}>
            {renderSection(section, index)}
          </SortableSectionItem>
        ))}
      </SortableContext>
    </DndContext>
  )
}
```

#### Step 3: Integrate into APTestEditor
**File:** `src/apBoost/pages/APTestEditor.jsx`
**Action:** Modify
**Details:**
- Import DraggableSectionList
- Replace section.map with DraggableSectionList
- Add `handleReorderSections` that handles drag-and-drop reordering

### Verification Steps
1. Add multiple sections to a test
2. Drag section by handle to reorder
3. Verify order updates immediately
4. Verify order persists after save
5. Test on mobile/touch devices

### Potential Risks
- Bundle size increase (~15KB)
- Touch device compatibility testing needed
- Accessibility: ensure keyboard navigation still works

**Recommendation:** Accept Option A for MVP. Document as known UX deviation.

---

## Issue 3: Add-to-Test Dropdown in Question Bank (PARTIAL)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** [Add to Test] dropdown to select target test/section
- **Current State:** Has "Add" button in picker mode that adds to current target section. However, it's not a dropdown selector - the target test/section is predetermined by the state saved when navigating from the test editor.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/pages/APQuestionBank.jsx` (lines 99-106) - Current Add button
  - `src/apBoost/pages/APQuestionBank.jsx` (lines 291-361) - Add to test handlers
  - `src/apBoost/services/apTeacherService.js` (lines 27-45) - `getTeacherTests` function
  - `src/apBoost/services/apQuestionService.js` (lines 240-270) - `addQuestionsToSection` function
- **Current Implementation:**
  - Navigating from test editor saves state to `sessionStorage` including `targetSectionIndex`
  - Question Bank reads this state and adds to that specific section
  - No way to change target without going back to test editor
- **Gap:** No dropdown to select target test and section directly from Question Bank
- **Dependencies:** Need to load teacher's tests and their sections

### Fix Plan

#### Step 1: Create TestSectionSelector component
**File:** `src/apBoost/components/teacher/TestSectionSelector.jsx` (NEW)
**Action:** Create
**Details:**
- Dropdown to select test from teacher's published tests
- Sub-dropdown for section within selected test
- Shows current selection as badge

```jsx
import { useState, useEffect } from 'react'
import { getTeacherTests } from '../../services/apTeacherService'

export default function TestSectionSelector({ teacherId, onSelect, currentTestId, currentSectionIndex }) {
  const [tests, setTests] = useState([])
  const [selectedTestId, setSelectedTestId] = useState(currentTestId || '')
  const [selectedSectionIndex, setSelectedSectionIndex] = useState(currentSectionIndex ?? -1)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    async function loadTests() {
      const data = await getTeacherTests(teacherId)
      // Only show published tests or tests being edited
      setTests(data.filter(t => t.isPublished || t.id === currentTestId))
      setLoading(false)
    }
    loadTests()
  }, [teacherId, currentTestId])

  const selectedTest = tests.find(t => t.id === selectedTestId)
  const sections = selectedTest?.sections || []

  const handleTestChange = (testId) => {
    setSelectedTestId(testId)
    setSelectedSectionIndex(-1) // Reset section
    onSelect(testId, -1)
  }

  const handleSectionChange = (index) => {
    setSelectedSectionIndex(index)
    onSelect(selectedTestId, index)
  }

  if (loading) return <span className="text-text-muted text-sm">Loading...</span>

  return (
    <div className="flex items-center gap-2">
      <select
        value={selectedTestId}
        onChange={(e) => handleTestChange(e.target.value)}
        className="px-2 py-1 text-sm rounded-[--radius-input] border border-border-default bg-surface text-text-primary"
      >
        <option value="">Select Test...</option>
        {tests.map(test => (
          <option key={test.id} value={test.id}>{test.title}</option>
        ))}
      </select>

      {selectedTestId && sections.length > 0 && (
        <select
          value={selectedSectionIndex}
          onChange={(e) => handleSectionChange(parseInt(e.target.value))}
          className="px-2 py-1 text-sm rounded-[--radius-input] border border-border-default bg-surface text-text-primary"
        >
          <option value={-1}>Select Section...</option>
          {sections.map((section, idx) => (
            <option key={idx} value={idx}>{section.title || `Section ${idx + 1}`}</option>
          ))}
        </select>
      )}
    </div>
  )
}
```

#### Step 2: Integrate selector into APQuestionBank
**File:** `src/apBoost/pages/APQuestionBank.jsx`
**Action:** Modify
**Details:**
- Import TestSectionSelector
- Add state for selected test/section
- Initialize from sessionStorage if in picker mode
- Allow changing target when not in strict picker mode
- Update add handlers to use selected target

```jsx
// Add state (around line 219)
const [targetTestId, setTargetTestId] = useState('')
const [targetSectionIndex, setTargetSectionIndex] = useState(-1)

// Initialize from sessionStorage on mount
useEffect(() => {
  const savedState = sessionStorage.getItem('testEditor_state')
  if (savedState) {
    const state = JSON.parse(savedState)
    setTargetTestId(state.testId || '')
    setTargetSectionIndex(state.targetSectionIndex ?? -1)
  }
}, [])

// Add handler
const handleTargetChange = (testId, sectionIndex) => {
  setTargetTestId(testId)
  setTargetSectionIndex(sectionIndex)
}
```

#### Step 3: Add selector to Question Bank header
**File:** `src/apBoost/pages/APQuestionBank.jsx`
**Action:** Modify
**Details:**
- Add TestSectionSelector below filters or in header area
- Show "Adding to: [Test Name] > [Section Name]" indicator
- Update add buttons to be disabled if no target selected

```jsx
// Add in header area (around line 413)
{!isPickerMode && (
  <div className="bg-surface rounded-[--radius-card] border border-border-default p-4 mb-6">
    <div className="flex items-center gap-4">
      <span className="text-text-secondary text-sm">Add questions to:</span>
      <TestSectionSelector
        teacherId={user?.uid}
        onSelect={handleTargetChange}
        currentTestId={targetTestId}
        currentSectionIndex={targetSectionIndex}
      />
    </div>
  </div>
)}
```

#### Step 4: Update add handlers to use dynamic target
**File:** `src/apBoost/pages/APQuestionBank.jsx`
**Action:** Modify
**Details:**
- Modify `handleAddSingleToTest` and `handleAddSelectedToTest`
- Use `targetTestId` and `targetSectionIndex` instead of sessionStorage
- Add validation that target is selected

### Verification Steps
1. Navigate to Question Bank directly (not from test editor)
2. Select a test from dropdown
3. Select a section from dropdown
4. Add questions using Add button
5. Verify questions appear in the selected section
6. Test bulk add with selected questions

### Potential Risks
- Need to handle case where test is deleted while user is in Question Bank
- Session storage state may conflict with dropdown selection - clear sessionStorage when using dropdown

---

## Issue 4: Search to Add Individual Students (MISSING)

### Audit Finding
- **Status:** ❌ Missing
- **Criterion:** Search to add individual students
- **Current State:** No search functionality for individual students. Only class-level selection is available.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/components/teacher/AssignTestModal.jsx` (lines 174-191) - Class selection UI
  - `src/apBoost/services/apTeacherService.js` (lines 185-223) - `getClassStudents` function exists
  - No existing student search function in codebase
- **Current Implementation:**
  - Classes are shown with checkboxes
  - All students in selected classes are automatically included
  - No way to add individual students outside of classes
- **Gap:** No search input, no student list, no individual selection
- **Dependencies:** Need to create a student search function

### Fix Plan

#### Step 1: Create searchStudents service function
**File:** `src/apBoost/services/apTeacherService.js`
**Action:** Add function
**Details:**
```javascript
/**
 * Search for students by name or email
 * @param {string} searchTerm - Search query
 * @param {string} teacherId - Teacher's user ID (to find students in their classes)
 * @returns {Promise<Array>} Array of student objects
 */
export async function searchStudents(searchTerm, teacherId) {
  try {
    if (!searchTerm || searchTerm.length < 2) {
      return []
    }

    // Get all students from teacher's classes first
    const classes = await getTeacherClasses(teacherId)
    const studentIds = new Set()
    classes.forEach(cls => {
      (cls.studentIds || []).forEach(id => studentIds.add(id))
    })

    if (studentIds.size === 0) {
      return []
    }

    // Fetch student details and filter by search term
    const students = []
    const searchLower = searchTerm.toLowerCase()

    for (const studentId of studentIds) {
      try {
        const userRef = doc(db, 'users', studentId)
        const userSnap = await getDoc(userRef)
        if (userSnap.exists()) {
          const userData = userSnap.data()
          const name = userData.displayName || ''
          const email = userData.email || ''

          // Match by name or email
          if (name.toLowerCase().includes(searchLower) ||
              email.toLowerCase().includes(searchLower)) {
            students.push({
              id: userSnap.id,
              displayName: name,
              email: email,
            })
          }
        }
      } catch {
        // Skip students that can't be fetched
      }
    }

    return students.slice(0, 20) // Limit results
  } catch (error) {
    logError('apTeacherService.searchStudents', { searchTerm, teacherId }, error)
    throw error
  }
}
```

#### Step 2: Add student search UI to AssignTestModal
**File:** `src/apBoost/components/teacher/AssignTestModal.jsx`
**Action:** Modify
**Details:**
- Add search input field
- Add state for search results and individually selected students
- Display search results as a selectable list
- Track individual students separately from class selections

```jsx
// Add imports
import { getTeacherClasses, searchStudents } from '../../services/apTeacherService'

// Add state (around line 44)
const [studentSearch, setStudentSearch] = useState('')
const [searchResults, setSearchResults] = useState([])
const [selectedStudentIds, setSelectedStudentIds] = useState(new Set())
const [searching, setSearching] = useState(false)

// Add search handler
const handleStudentSearch = async (term) => {
  setStudentSearch(term)
  if (term.length < 2) {
    setSearchResults([])
    return
  }

  setSearching(true)
  try {
    const results = await searchStudents(term, teacherId)
    setSearchResults(results)
  } catch (err) {
    console.error('Search failed:', err)
  } finally {
    setSearching(false)
  }
}

// Add student toggle handler
const handleToggleStudent = (studentId) => {
  const newSelected = new Set(selectedStudentIds)
  if (newSelected.has(studentId)) {
    newSelected.delete(studentId)
  } else {
    newSelected.add(studentId)
  }
  setSelectedStudentIds(newSelected)
}
```

#### Step 3: Add search UI section
**File:** `src/apBoost/components/teacher/AssignTestModal.jsx`
**Action:** Modify
**Details:**
- Add after class selection section (around line 191)

```jsx
{/* Individual student search */}
<div className="mb-6">
  <h3 className="font-medium text-text-primary mb-3">Add Individual Students</h3>
  <input
    type="text"
    value={studentSearch}
    onChange={(e) => handleStudentSearch(e.target.value)}
    placeholder="Search by name or email..."
    className="w-full px-3 py-2 rounded-[--radius-input] border border-border-default bg-surface text-text-primary mb-2"
  />

  {searching && (
    <p className="text-text-muted text-sm">Searching...</p>
  )}

  {searchResults.length > 0 && (
    <div className="border border-border-default rounded-[--radius-card] max-h-40 overflow-auto">
      {searchResults.map(student => (
        <label
          key={student.id}
          className="flex items-center gap-3 py-2 px-3 hover:bg-hover cursor-pointer border-b border-border-muted last:border-b-0"
        >
          <input
            type="checkbox"
            checked={selectedStudentIds.has(student.id)}
            onChange={() => handleToggleStudent(student.id)}
            className="w-4 h-4 rounded border-border-default text-brand-primary"
          />
          <div>
            <span className="text-text-primary">{student.displayName || 'Student'}</span>
            <span className="text-text-muted text-sm ml-2">{student.email}</span>
          </div>
        </label>
      ))}
    </div>
  )}

  {selectedStudentIds.size > 0 && (
    <div className="mt-2 text-text-secondary text-sm">
      {selectedStudentIds.size} individual student(s) selected
    </div>
  )}
</div>
```

#### Step 4: Update getTotalStudents and handleAssign
**File:** `src/apBoost/components/teacher/AssignTestModal.jsx`
**Action:** Modify
**Details:**
- Modify `getTotalStudents` to include individual selections
- Modify `handleAssign` to merge class students with individual students

```javascript
// Update getTotalStudents (around line 81)
const getTotalStudents = () => {
  const studentSet = new Set()

  // Add students from selected classes
  classes.forEach(cls => {
    if (selectedClassIds.has(cls.id)) {
      (cls.studentIds || []).forEach(id => studentSet.add(id))
    }
  })

  // Add individually selected students
  selectedStudentIds.forEach(id => studentSet.add(id))

  return studentSet.size
}

// Update handleAssign (around line 103)
// Collect all student IDs from selected classes AND individual selections
const allStudentIds = new Set()
classes.forEach(cls => {
  if (selectedClassIds.has(cls.id)) {
    (cls.studentIds || []).forEach(id => allStudentIds.add(id))
  }
})
// Add individually selected students
selectedStudentIds.forEach(id => allStudentIds.add(id))
```

### Verification Steps
1. Open Assign Test modal
2. Type a student name in search box
3. Verify matching students appear
4. Select individual students via checkbox
5. Verify student count updates correctly
6. Submit assignment and verify individual students received it
7. Test searching by email
8. Test that same student isn't double-counted if in a selected class AND individually selected

### Potential Risks
- Search may be slow for teachers with many students - mitigate with debounce
- Need to handle duplicate students (in class AND individually selected) - use Set
- Search only finds students in teacher's classes - this is intentional for security

---

## Issue 5: Max Attempts Default Value (PARTIAL)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Settings - Max Attempts (number, default 3)
- **Current State:** Max attempts selector is implemented, but default is 1 (line 48) instead of 3.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/components/teacher/AssignTestModal.jsx` (line 48) - `const [maxAttempts, setMaxAttempts] = useState(1)`
  - `src/apBoost/services/apTeacherService.js` (line 239) - `maxAttempts: assignmentData.maxAttempts || 1`
- **Current Implementation:** Default value is 1 in component state
- **Gap:** Spec requires default of 3
- **Dependencies:** Also update service fallback for consistency

### Fix Plan

#### Step 1: Change default in component state
**File:** `src/apBoost/components/teacher/AssignTestModal.jsx`
**Action:** Modify (single line change)
**Details:**
- Line 48: Change `useState(1)` to `useState(3)`

```javascript
// Before
const [maxAttempts, setMaxAttempts] = useState(1)

// After
const [maxAttempts, setMaxAttempts] = useState(3)
```

#### Step 2: Update service fallback for consistency
**File:** `src/apBoost/services/apTeacherService.js`
**Action:** Modify (single line change)
**Details:**
- Line 239: Change fallback from 1 to 3

```javascript
// Before
maxAttempts: assignmentData.maxAttempts || 1,

// After
maxAttempts: assignmentData.maxAttempts || 3,
```

### Verification Steps
1. Open Assign Test modal
2. Verify Max Attempts dropdown shows "3" as default
3. Create an assignment without changing the value
4. Check Firestore document to confirm maxAttempts is 3

### Potential Risks
- None - simple default value change
- Existing assignments with maxAttempts=1 are unaffected

---

## Issue 6: Real-Time Gradebook Updates (PARTIAL)

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** Updates in real-time when grading completes
- **Current State:** Results refresh after save/complete via `handleSave` callback, but not using real-time Firestore listeners. Requires save action to trigger refresh.

### Code Analysis
- **Relevant Files:**
  - `src/apBoost/pages/APGradebook.jsx` (lines 145-179) - `loadResults` function using `getDocs`
  - `src/apBoost/pages/APGradebook.jsx` (lines 200-218) - `handleSave` manually refreshes
  - `src/apBoost/services/apGradingService.js` (lines 26-101) - `getPendingGrades` uses one-time query
- **Current Implementation:**
  - Uses `useEffect` with `getDocs` for one-time fetch
  - `handleSave` callback triggers manual re-fetch
- **Gap:** No real-time updates via Firestore `onSnapshot`
- **Dependencies:** Need to use `onSnapshot` instead of `getDocs`

### Fix Plan

#### Step 1: Create real-time hook for pending grades
**File:** `src/apBoost/hooks/usePendingGrades.js` (NEW)
**Action:** Create
**Details:**
```javascript
import { useState, useEffect } from 'react'
import { db } from '../../firebase'
import { collection, doc, getDoc, query, where, orderBy, onSnapshot } from 'firebase/firestore'
import { COLLECTIONS, GRADING_STATUS } from '../utils/apTypes'
import { logError } from '../utils/logError'

/**
 * Hook for real-time pending grades subscription
 * @param {string} teacherId - Teacher's user ID
 * @param {Object} filters - Filter options
 * @returns {Object} { results, loading, error }
 */
export function usePendingGrades(teacherId, filters = {}) {
  const [results, setResults] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)

  useEffect(() => {
    if (!teacherId) {
      setLoading(false)
      return
    }

    const resultsRef = collection(db, COLLECTIONS.TEST_RESULTS)

    // Build query constraints
    let constraints = []

    // Filter by grading status
    if (filters.status && filters.status !== 'all') {
      if (filters.status === 'pending') {
        constraints.push(where('gradingStatus', 'in', [GRADING_STATUS.PENDING, GRADING_STATUS.IN_PROGRESS]))
      } else {
        constraints.push(where('gradingStatus', '==', filters.status))
      }
    }

    if (filters.testId && filters.testId !== 'all') {
      constraints.push(where('testId', '==', filters.testId))
    }

    if (filters.classId && filters.classId !== 'all') {
      constraints.push(where('classId', '==', filters.classId))
    }

    constraints.push(orderBy('completedAt', 'desc'))

    const q = query(resultsRef, ...constraints)

    // Set up real-time listener
    const unsubscribe = onSnapshot(
      q,
      async (snapshot) => {
        const resultsData = []

        for (const docSnap of snapshot.docs) {
          const data = docSnap.data()

          // Get student info
          let studentName = 'Unknown Student'
          if (data.studentId) {
            try {
              const userDoc = await getDoc(doc(db, 'users', data.studentId))
              if (userDoc.exists()) {
                const userData = userDoc.data()
                studentName = userData.displayName || userData.email || 'Student'
              }
            } catch {
              // Ignore user fetch errors
            }
          }

          // Get test info
          let testTitle = 'Practice Test'
          if (data.testId) {
            try {
              const testDoc = await getDoc(doc(db, COLLECTIONS.TESTS, data.testId))
              if (testDoc.exists()) {
                testTitle = testDoc.data().title || 'Practice Test'
              }
            } catch {
              // Ignore test fetch errors
            }
          }

          resultsData.push({
            id: docSnap.id,
            ...data,
            studentName,
            testTitle,
          })
        }

        setResults(resultsData)
        setLoading(false)
        setError(null)
      },
      (err) => {
        logError('usePendingGrades', { teacherId, filters }, err)
        setError(err.message || 'Failed to load gradebook')
        setLoading(false)
      }
    )

    // Cleanup subscription on unmount or filter change
    return () => unsubscribe()
  }, [teacherId, filters.status, filters.testId, filters.classId])

  return { results, loading, error }
}
```

#### Step 2: Update APGradebook to use the hook
**File:** `src/apBoost/pages/APGradebook.jsx`
**Action:** Modify
**Details:**
- Import the new hook
- Replace manual loading logic with hook
- Remove `handleSave` refresh logic (no longer needed)

```jsx
// Add import
import { usePendingGrades } from '../hooks/usePendingGrades'

// Replace data state and loading useEffect (lines 109-179)
// With:
const filters = useMemo(() => ({
  status: statusFilter,
  testId: testFilter,
  classId: classFilter,
}), [statusFilter, testFilter, classFilter])

const { results, loading, error } = usePendingGrades(user?.uid, filters)

// Remove the loadResults useEffect entirely

// Simplify handleSave - no longer needs to refresh
const handleSave = () => {
  // Real-time listener will automatically update
  // Optionally close the panel
}
```

#### Step 3: Add useMemo import
**File:** `src/apBoost/pages/APGradebook.jsx`
**Action:** Modify
**Details:**
- Add `useMemo` to React imports

```jsx
import { useState, useEffect, useMemo } from 'react'
```

### Verification Steps
1. Open Gradebook in two browser tabs
2. Grade a submission in one tab
3. Verify the other tab updates automatically without refresh
4. Change grading status and verify list updates
5. Test that filters still work correctly with real-time data

### Potential Risks
- More Firestore reads due to real-time subscription - acceptable for this use case
- Need to handle cleanup properly to avoid memory leaks - done via unsubscribe
- Student/test info fetching adds latency - consider caching in future

---

## Implementation Order

Recommended order to implement fixes (considering dependencies):

1. **Issue 5: Max Attempts Default** - Simple one-line fix, no dependencies
2. **Issue 1: Question Drag-to-Reorder** - Foundational feature, uses existing service function
3. **Issue 4: Individual Student Search** - Independent feature, self-contained
4. **Issue 3: Add-to-Test Dropdown** - Enhances existing feature, independent
5. **Issue 6: Real-Time Gradebook** - Creates new hook pattern, moderate complexity
6. **Issue 2: Section Drag-and-Drop** - Optional enhancement, lowest priority

## Cross-Cutting Concerns

1. **Consistent Move Button Pattern**: Issues 1 and 2 both deal with reordering. Consider extracting a reusable `MoveButtons` component:
```jsx
function MoveButtons({ onMoveUp, onMoveDown, canMoveUp, canMoveDown }) {
  return (
    <div className="flex items-center gap-1">
      <button onClick={onMoveUp} disabled={!canMoveUp} className="...">^</button>
      <button onClick={onMoveDown} disabled={!canMoveDown} className="...">v</button>
    </div>
  )
}
```

2. **Search Debouncing**: Issue 4 (student search) should use debounce to avoid excessive API calls. Consider creating a reusable `useDebounce` hook if not already present.

3. **Real-Time Pattern**: Issue 6 establishes a pattern for real-time Firestore subscriptions. This pattern should be documented and reused for other real-time features.

## Notes for Implementer

1. **Test Thoroughly**: Each fix should be tested in isolation before integration
2. **Check Mobile**: Ensure all UI changes work well on mobile devices
3. **Accessibility**: Move buttons should have proper ARIA labels
4. **Error Handling**: All async operations should have try/catch with user-friendly error messages
5. **Log Changes**: Remember to update `change_action_log_ap.md` with all changes
6. **Design Tokens**: All new UI elements must use design tokens from `/src/index.css`

## Quality Checklist
- [x] Every ⚠️/❌/❓ issue from the audit has a fix plan
- [x] Each fix plan includes specific file paths and line numbers
- [x] Each fix plan references existing code patterns to follow
- [x] Dependencies between fixes are identified
- [x] Implementation order is logical
- [x] Verification steps are actionable
- [x] Potential risks are documented

---

## Part 2: Codebase Facts

# CODEBASE_FACTS__11__11.1_to_11.5

**Generated:** 2026-01-14
**Inspector:** Claude Agent
**Chunk ID:** 11__11.1_to_11.5

---

## 1) Canonical Data Schema / Source-of-Truth

Found: **Yes**

### Firestore Collections
- **Tests:** `ap_tests`
- **Questions:** `ap_questions`
- **Classes:** `ap_classes`
- **Assignments:** `ap_assignments`
- **Test Results:** `ap_test_results`
- **Session State:** `ap_session_state`
- **Stimuli:** `ap_stimuli`

### Test Document Schema (sections and question ordering)
- Tests contain an embedded `sections` array
- Each section has a `questionIds` array storing ordered question IDs as strings
- Section structure: `{ title, sectionType, timeLimit, multiplier, questionIds: string[] }`

### Class Document Schema
- Contains `studentIds` array of user IDs
- Contains `teacherId` field
- Contains `name` and optional `period` fields

### Assignment Document Schema
- Fields: `testId`, `classIds[]`, `studentIds[]`, `dueDate`, `maxAttempts`, `frqSubmissionType`, `assignedBy`, `assignedAt`

### Evidence:

**`src/apBoost/utils/apTypes.js:89-98`**
```javascript
// Collection names
export const COLLECTIONS = {
  TESTS: 'ap_tests',
  QUESTIONS: 'ap_questions',
  STIMULI: 'ap_stimuli',
  SESSION_STATE: 'ap_session_state',
  TEST_RESULTS: 'ap_test_results',
  CLASSES: 'ap_classes',
  ASSIGNMENTS: 'ap_assignments',
}
```

**`src/apBoost/pages/APTestEditor.jsx:267-278`** (Section structure in handleAddSection)
```javascript
const handleAddSection = () => {
  setSections([
    ...sections,
    {
      title: `Section ${sections.length + 1}`,
      sectionType: SECTION_TYPE.MCQ,
      timeLimit: 45,
      multiplier: 1.0,
      questionIds: [],
    }
  ])
}
```

**`src/apBoost/services/apTeacherService.js:193-196`** (Class studentIds structure)
```javascript
const classData = classSnap.data()
const studentIds = classData.studentIds || []
```

---

## 2) Write Paths

Found: **Yes**

### 2.1 Question Reorder Within Section
- **Function:** `reorderSectionQuestions(testId, sectionIndex, newOrder)`
- **Location:** `src/apBoost/services/apQuestionService.js:317-346`
- **Write Method:** `updateDoc` (no transaction/batch)
- **Target:** Entire `sections` array is rewritten
- **Import Status:** Imported in APTestEditor.jsx but **NEVER CALLED**

**Evidence - `src/apBoost/services/apQuestionService.js:317-346`:**
```javascript
export async function reorderSectionQuestions(testId, sectionIndex, newOrder) {
  try {
    const testRef = doc(db, COLLECTIONS.TESTS, testId)
    const testSnap = await getDoc(testRef)

    if (!testSnap.exists()) {
      throw new Error('Test not found')
    }

    const testData = testSnap.data()
    const sections = [...(testData.sections || [])]

    if (sectionIndex < 0 || sectionIndex >= sections.length) {
      throw new Error('Invalid section index')
    }

    // Update question order
    const section = { ...sections[sectionIndex] }
    section.questionIds = newOrder
    sections[sectionIndex] = section

    await updateDoc(testRef, {
      sections,
      updatedAt: serverTimestamp(),
    })
  } catch (error) {
    logError('apQuestionService.reorderSectionQuestions', { testId, sectionIndex }, error)
    throw error
  }
}
```

**Evidence - `src/apBoost/pages/APTestEditor.jsx:6`:** (Import but unused)
```javascript
import { getQuestionsByIds, removeQuestionFromSection, reorderSectionQuestions } from '../services/apQuestionService'
```

### 2.2 Section Reorder
- **Handler:** `handleMoveSection(index, direction)`
- **Location:** `src/apBoost/pages/APTestEditor.jsx:294-304`
- **Write Method:** Local state only (`setSections`) - **NOT immediately persisted**
- **Persistence:** Only when test is saved via `handleSave()`

**Evidence - `src/apBoost/pages/APTestEditor.jsx:294-304`:**
```javascript
const handleMoveSection = (index, direction) => {
  const newIndex = direction === 'up' ? index - 1 : index + 1
  if (newIndex < 0 || newIndex >= sections.length) return

  const newSections = [...sections]
  const temp = newSections[index]
  newSections[index] = newSections[newIndex]
  newSections[newIndex] = temp
  setSections(newSections)
}
```

### 2.3 Add Questions to Section
- **Function:** `addQuestionsToSection(testId, sectionIndex, questionIds)`
- **Location:** `src/apBoost/services/apQuestionService.js:240-270`
- **Write Method:** `updateDoc` - rewrites entire `sections` array
- **Concurrency:** Performs read-then-write (potential race condition)

**Evidence - `src/apBoost/services/apQuestionService.js:256-265`:**
```javascript
// Add questions to section
const section = { ...sections[sectionIndex] }
const existingIds = section.questionIds || []
section.questionIds = [...existingIds, ...questionIds]
sections[sectionIndex] = section

await updateDoc(testRef, {
  sections,
  updatedAt: serverTimestamp(),
})
```

### 2.4 Create Assignment (includes maxAttempts)
- **Function:** `createAssignment(assignmentData)`
- **Location:** `src/apBoost/services/apTeacherService.js:230-251`
- **Write Method:** `addDoc`
- **maxAttempts default:** Falls back to `1` if not provided

**Evidence - `src/apBoost/services/apTeacherService.js:234-245`:**
```javascript
const newAssignment = {
  testId: assignmentData.testId,
  classIds: assignmentData.classIds || [],
  studentIds: assignmentData.studentIds || [],
  dueDate: assignmentData.dueDate || null,
  maxAttempts: assignmentData.maxAttempts || 1,
  frqSubmissionType: assignmentData.frqSubmissionType || 'TYPED',
  assignedBy: assignmentData.assignedBy,
  assignedAt: serverTimestamp(),
}
```

### 2.5 Gradebook Data Fetch
- **Function:** `getPendingGrades(teacherId, filters)`
- **Location:** `src/apBoost/services/apGradingService.js:26-101`
- **Read Method:** `getDocs` (one-time fetch)
- **Real-time:** **NO** `onSnapshot` usage

**Evidence - `src/apBoost/services/apGradingService.js:54-55`:**
```javascript
const q = query(resultsRef, ...constraints)
const snapshot = await getDocs(q)
```

---

## 3) Offline/Resilience Mechanics

Found: **No**

Not applicable - No offline/resilience mechanics found in the inspected flows:
- Question editor reorder: No retry/offline handling
- Question bank add-to-test: No retry/offline handling
- Assign test: No retry/offline handling
- Gradebook: No caching/retry mechanism

Note: The project has `useOfflineQueue.js` hook but it is NOT used in the flows covered by this audit chunk.

---

## 4) UI/Flow Entry Points

Found: **Yes**

### Routes Configuration
- **Location:** `src/apBoost/routes.jsx`

| Route | Component | Description |
|-------|-----------|-------------|
| `/ap/teacher/test/:testId/edit` | APTestEditor | Test editor with sections |
| `/ap/teacher/questions` | APQuestionBank | Question bank (supports `?picker=true`) |
| `/ap/teacher/question/:questionId/edit` | APQuestionEditor | Question create/edit |
| `/ap/gradebook` | APGradebook | Teacher gradebook |
| `/ap/teacher/test/:testId/assign` | APAssignTest | Dedicated assignment page |

**Evidence - `src/apBoost/routes.jsx:59-98`:**
```jsx
<Route
  path="/ap/teacher/test/:testId/edit"
  element={
    <PrivateRoute>
      <APTestEditor />
    </PrivateRoute>
  }
/>
<Route
  path="/ap/teacher/questions"
  element={
    <PrivateRoute>
      <APQuestionBank />
    </PrivateRoute>
  }
/>
<Route
  path="/ap/gradebook"
  element={
    <PrivateRoute>
      <APGradebook />
    </PrivateRoute>
  }
/>
```

### AssignTestModal Entry Point
- **Invoked from:** APTeacherDashboard (inferred from import pattern)
- **Component:** `src/apBoost/components/teacher/AssignTestModal.jsx`

---

## 5) Must-Answer Questions (from checklist)

### Q1: What is the authoritative data shape for test sections and their question ordering?

**Conclusion:** Yes - Fully documented

- **Location:** Embedded `sections` array in test document
- **Ordering:** `sections[sectionIndex].questionIds` is an array of string IDs
- **Type:** `string[]` (array of question document IDs)
- **Order significance:** Array index determines display/execution order

**Evidence - `src/apBoost/pages/APTestEditor.jsx:340-344`:**
```javascript
const getSectionQuestions = (section) => {
  return (section.questionIds || [])
    .map(id => questionsCache[id])
    .filter(Boolean)
}
```

---

### Q2: How does `reorderSectionQuestions(testId, sectionIndex, newOrder)` persist ordering?

**Conclusion:** Yes - Fully documented

- **Collection:** `ap_tests`
- **Document:** Test document identified by `testId`
- **Field Path:** `sections` (entire array is rewritten)
- **Method:** `updateDoc` - no transaction or batch
- **Idempotency Risk:** Read-then-write pattern without transaction

**Evidence - `src/apBoost/services/apQuestionService.js:333-341`:**
```javascript
// Update question order
const section = { ...sections[sectionIndex] }
section.questionIds = newOrder
sections[sectionIndex] = section

await updateDoc(testRef, {
  sections,
  updatedAt: serverTimestamp(),
})
```

---

### Q3: Is there any existing UI control for question reordering in APTestEditor today?

**Conclusion:** **NO** - No UI controls exist

- Current question row only has "Edit" link and "Remove" button
- No up/down buttons for questions
- No drag handles
- `reorderSectionQuestions` is imported but never called from UI

**Evidence - `src/apBoost/pages/APTestEditor.jsx:112-139`:** (Question row rendering)
```jsx
{questions.map((question, idx) => (
  <div
    key={question.id}
    className="flex items-center justify-between py-2 px-3 bg-muted rounded-[--radius-sm]"
  >
    <div className="flex-1 min-w-0">
      <span className="text-text-muted text-sm mr-2">{idx + 1}.</span>
      <span className="text-text-primary text-sm truncate">
        {question.questionText?.substring(0, 60)}
        {question.questionText?.length > 60 ? '...' : ''}
      </span>
    </div>
    <div className="flex items-center gap-2 ml-2">
      <Link
        to={`/ap/teacher/question/${question.id}/edit`}
        className="text-brand-primary text-xs hover:underline"
      >
        Edit
      </Link>
      <button
        onClick={() => onRemoveQuestion(question.id)}
        className="text-error-text text-xs hover:underline"
      >
        Remove
      </button>
    </div>
  </div>
))}
```

---

### Q4: How are sections reordered today, and is the order persisted immediately?

**Conclusion:** Yes - Documented

- **UI Controls:** Up/down buttons (^ and v characters)
- **Handler:** `handleMoveSection(index, direction)`
- **Persistence:** **NOT IMMEDIATE** - Only local state update
- **When persisted:** On `handleSave()` call (Save Draft or Save and Publish)

**Evidence - `src/apBoost/pages/APTestEditor.jsx:42-57`:** (Section move buttons)
```jsx
<button
  onClick={() => onMoveSection('up')}
  disabled={!canMoveUp}
  className="p-1 text-text-muted hover:text-text-primary disabled:opacity-30"
  title="Move up"
>
  <span className="text-lg">^</span>
</button>
<button
  onClick={() => onMoveSection('down')}
  disabled={!canMoveDown}
  className="p-1 text-text-muted hover:text-text-primary disabled:opacity-30"
  title="Move down"
>
  <span className="text-lg">v</span>
</button>
```

---

### Q5: How does APQuestionBank determine the target test/section when adding questions?

**Conclusion:** Yes - Fully documented

- **Storage:** `sessionStorage` with key `'testEditor_state'`
- **Fields stored:**
  - `testId` (null for new test)
  - `title`, `subject`, `testType`
  - `sections` (array)
  - `scoreRanges`
  - `targetSectionIndex` (integer)
- **Picker Mode Flag:** URL query param `?picker=true`

**Evidence - `src/apBoost/pages/APTestEditor.jsx:306-318`:** (Write to sessionStorage)
```javascript
const handleAddQuestions = (sectionIndex) => {
  sessionStorage.setItem('testEditor_state', JSON.stringify({
    testId: isNew ? null : testId,
    title,
    subject,
    testType,
    sections,
    scoreRanges,
    targetSectionIndex: sectionIndex,
  }))
  navigate('/ap/teacher/questions?picker=true')
}
```

**Evidence - `src/apBoost/pages/APQuestionBank.jsx:294-305`:** (Read from sessionStorage)
```javascript
const savedState = sessionStorage.getItem('testEditor_state')
if (!savedState) {
  alert('No test editor state found. Please start from the test editor.')
  return
}

const state = JSON.parse(savedState)
const { testId, targetSectionIndex } = state
```

---

### Q6: Does any "test/section dropdown selector" already exist anywhere (e.g., TestSectionSelector)?

**Conclusion:** **NOT FOUND**

- No `TestSectionSelector` component exists in the codebase
- The component is only mentioned in the fix plan as a proposed new file
- Question Bank currently only works via sessionStorage picker-mode flow

**Search performed:**
- Grep for `TestSectionSelector` - only found in fix plan markdown files
- No component file at `src/apBoost/components/teacher/TestSectionSelector.jsx`

---

### Q7: In AssignTestModal, how are students selected today?

**Conclusion:** Yes - Documented

- **Selection Method:** By class only (class checkboxes)
- **Student IDs Source:** `cls.studentIds` array from class documents
- **No individual student selection:** No search/add for individual students
- **Aggregation:** All studentIds from selected classes are combined

**Evidence - `src/apBoost/components/teacher/AssignTestModal.jsx:102-108`:**
```javascript
// Collect all student IDs from selected classes
const allStudentIds = new Set()
classes.forEach(cls => {
  if (selectedClassIds.has(cls.id)) {
    (cls.studentIds || []).forEach(id => allStudentIds.add(id))
  }
})
```

**Evidence - `src/apBoost/components/teacher/AssignTestModal.jsx:9-31`:** (ClassCheckbox component)
```jsx
function ClassCheckbox({ cls, checked, onChange }) {
  const studentCount = cls.studentIds?.length || 0

  return (
    <label className="flex items-center gap-3 py-2 px-3 rounded-[--radius-sm] hover:bg-hover cursor-pointer">
      <input
        type="checkbox"
        checked={checked}
        onChange={(e) => onChange(e.target.checked)}
        ...
      />
      ...
    </label>
  )
}
```

---

### Q8: Is there any existing student search function/service today?

**Conclusion:** **NOT FOUND**

- No `searchStudents` function exists in any service file
- No `searchUsers` function exists
- The `users` collection is queried only by individual ID (`getDoc`)
- Grep for `searchStudents` found only fix plan proposals

**Evidence - `src/apBoost/services/apTeacherService.js:201-216`:** (Individual student fetch only)
```javascript
// Fetch student details
const students = []
for (const studentId of studentIds) {
  try {
    const userRef = doc(db, 'users', studentId)
    const userSnap = await getDoc(userRef)
    if (userSnap.exists()) {
      students.push({
        id: userSnap.id,
        ...userSnap.data()
      })
    }
  } catch {
    // Skip students that can't be fetched
  }
}
```

---

### Q9: Where is `maxAttempts` set for assignments, and what defaults/fallbacks exist?

**Conclusion:** Yes - Fully documented

| Location | Default Value | Evidence |
|----------|---------------|----------|
| UI State (AssignTestModal) | `1` | Line 48 |
| Service fallback (createAssignment) | `1` | Line 239 |

**Evidence - `src/apBoost/components/teacher/AssignTestModal.jsx:48`:** (UI default)
```javascript
const [maxAttempts, setMaxAttempts] = useState(1)
```

**Evidence - `src/apBoost/services/apTeacherService.js:239`:** (Service fallback)
```javascript
maxAttempts: assignmentData.maxAttempts || 1,
```

**Note:** The fix plan mentions changing default to `3`, but current implementation uses `1`.

---

### Q10: Does APGradebook currently use one-time fetch or real-time listeners?

**Conclusion:** Yes - Documented as **ONE-TIME FETCH ONLY**

- **Current implementation:** Uses `getDocs` (one-time fetch)
- **Real-time listeners:** **NO `onSnapshot` usage** in APGradebook or apGradingService
- **Refresh mechanism:** Manual refresh via `handleSave()` callback

**Evidence - `src/apBoost/pages/APGradebook.jsx:145-179`:** (loadResults effect)
```javascript
useEffect(() => {
  async function loadResults() {
    if (!user) return

    try {
      setLoading(true)
      setError(null)

      const filters = {}
      // ... filter setup ...

      const data = await getPendingGrades(user.uid, filters)
      setResults(data)
    } catch (err) {
      logError('APGradebook.loadResults', { userId: user?.uid }, err)
      setError(err.message || 'Failed to load gradebook')
    } finally {
      setLoading(false)
    }
  }

  loadResults()
}, [user, statusFilter, testFilter, classFilter])
```

**Evidence - `src/apBoost/services/apGradingService.js:1-18`:** (No onSnapshot import)
```javascript
import { db } from '../../firebase'
import {
  collection,
  doc,
  getDoc,
  getDocs,
  updateDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
} from 'firebase/firestore'
```

**Grep confirmation:** No source files in `src/apBoost/**/*.{js,jsx}` contain `onSnapshot` usage.

---

## Summary Table

| Feature | Current State | Missing/Gap |
|---------|---------------|-------------|
| Question reorder within section | Service exists, UI missing | Need up/down buttons or drag-and-drop |
| Section reorder | Works (up/down buttons) | Consider drag-and-drop |
| Question Bank target selector | sessionStorage picker-mode | Consider dropdown selector |
| Individual student selection | Not implemented | Need search UI + service |
| maxAttempts default | Defaults to 1 | Consider changing to 3 |
| Gradebook real-time updates | One-time getDocs | Need onSnapshot listener |
| Drag-and-drop library | Not installed | Would need @dnd-kit or similar |

---

## Package.json Dependencies (relevant)

No drag-and-drop libraries installed:
- `@dnd-kit/core` - **NOT FOUND**
- `@dnd-kit/sortable` - **NOT FOUND**
- `react-beautiful-dnd` - **NOT FOUND**

**Evidence - `package.json:13-28`:** (dependencies section)
```json
"dependencies": {
  "@tailwindcss/postcss": "^4.1.17",
  "autoprefixer": "^10.4.22",
  "dotenv": "^17.2.3",
  "firebase": "^12.6.0",
  "firebase-admin": "^13.6.0",
  "jspdf": "^3.0.4",
  "jspdf-autotable": "^5.0.2",
  "lucide-react": "^0.556.0",
  "postcss": "^8.5.6",
  "react": "^19.2.0",
  "react-dom": "^19.2.0",
  "react-router-dom": "^7.9.6",
  "tailwindcss": "^4.1.17",
  "xlsx": "^0.18.5"
}
```
