# Section 2.3.1 to 2.4 - Fix Plan with Codebase Facts

> **What is this file?**
> This document combines two resources for implementing criteria section 2.3.1 to 2.4:
> 1. **Fix Plan** - Step-by-step implementation instructions for code changes
> 2. **Codebase Facts** - Relevant code snippets, file paths, and existing patterns from the codebase
>
> Use the Fix Plan as your guide and reference the Codebase Facts for accurate file locations and code context.

---

## Part 1: Fix Plan

# Fix Plan: Sections 2.3.1 to 2.5

**Planned by:** Claude Agent
**Date:** 2026-01-14
**Status:** COMPLETE
**Based on Audit:** section_2.3.1_to_2.4_criteria_audit.md

## Executive Summary
- Total Issues: 4
- ⚠️ Partial Implementations: 2
- ❌ Missing Features: 0
- ❓ Needs Investigation: 2 (both verified as implemented correctly)
- Estimated Complexity: Low-Medium

---

## Issue 1: FRQTextInput Missing onBlur Save Handler

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** "Saves on blur event"
- **Current State:** No `onBlur` handler present. Saving happens through onChange which queues to Firestore via useOfflineQueue.

### Code Analysis
- **Relevant Files:**
  - [FRQTextInput.jsx](src/apBoost/components/FRQTextInput.jsx) (lines 1-98) - FRQ textarea component, no blur handling
  - [APTestSession.jsx](src/apBoost/pages/APTestSession.jsx) (lines 439-445) - Renders FRQTextInput with setAnswer callback
  - [useTestSession.js](src/apBoost/hooks/useTestSession.js) (lines 328-359) - setAnswer function adds to queue
  - [useOfflineQueue.js](src/apBoost/hooks/useOfflineQueue.js) (lines 124-160) - Queue management with 1s debounce

- **Current Implementation:**
  - FRQTextInput receives `onChange` prop and calls it on every keystroke (line 34-38)
  - Parent (APTestSession) passes `setAnswer` from useTestSession as onChange
  - setAnswer adds action to IndexedDB queue and schedules flush with 1s debounce
  - No explicit blur handler to ensure data is captured when user navigates away

- **Gap:** If a user types in the textarea then immediately clicks "Next" or closes the browser, the final answer state might not be queued if no additional onChange events fire. While the queue system is robust, an explicit blur save adds a safety net.

- **Dependencies:**
  - The fix only touches FRQTextInput and APTestSession
  - No changes to useTestSession or useOfflineQueue needed - the existing setAnswer mechanism works fine

### Fix Plan

#### Step 1: Add onBlur prop to FRQTextInput
**File:** `src/apBoost/components/FRQTextInput.jsx`
**Action:** Modify
**Details:**
- Add `onBlur` to the destructured props (line 14 area)
- Add onBlur handler to the textarea element (line 64 area)
- The onBlur should call the provided onBlur callback with the current value
- Pattern to follow: Similar to how onChange is handled currently

```jsx
// Add to props:
onBlur = null, // Optional blur handler

// Add handler:
const handleBlur = () => {
  if (onBlur) {
    onBlur(value)
  }
}

// Add to textarea:
<textarea
  ...
  onBlur={handleBlur}
  ...
/>
```

#### Step 2: Pass onBlur to FRQTextInput in APTestSession
**File:** `src/apBoost/pages/APTestSession.jsx`
**Action:** Modify
**Details:**
- At line 439-445 where FRQTextInput is rendered, add onBlur prop
- Use the same setAnswer function for onBlur as used for onChange
- This ensures the current value is queued on blur

```jsx
<FRQTextInput
  subQuestion={currentQuestion?.subQuestions?.find(sq => sq.label === subQuestionLabel)}
  value={currentAnswer || ''}
  onChange={setAnswer}
  onBlur={setAnswer}  // ADD THIS LINE
  disabled={isSubmitting || isInvalidated}
/>
```

### Verification Steps
1. Start an FRQ question, type some text, click Next button - verify answer is saved
2. Type in FRQ, click outside the textarea (blur), check IndexedDB for queued action
3. Type in FRQ, close browser tab - verify beforeunload warning appears if queue not empty
4. Resume session after blur-save - verify answer was persisted

### Potential Risks
- **Risk:** Double-save if onChange fires immediately before blur
  - **Mitigation:** Queue system handles duplicates gracefully - latest value wins when flushed
- **Risk:** Performance impact of extra queue writes
  - **Mitigation:** Minimal - blur only fires once per field interaction, not on every keystroke

---

## Issue 2: DBQ Multi-Document Support Missing

### Audit Finding
- **Status:** ⚠️ Partial
- **Criterion:** "Displays multiple documents as stimulus"
- **Current State:** StimulusDisplay only handles a single stimulus object. DBQ type is supported but only shows one document.

### Code Analysis
- **Relevant Files:**
  - [FRQQuestionDisplay.jsx](src/apBoost/components/FRQQuestionDisplay.jsx) (lines 6-33) - StimulusDisplay component
  - [FRQQuestionDisplay.jsx](src/apBoost/components/FRQQuestionDisplay.jsx) (lines 85-160) - Main component, uses displayStimulus
  - [apTypes.js](src/apBoost/utils/apTypes.js) (lines 56-62) - STIMULUS_TYPE enum includes DOCUMENT

- **Current Implementation:**
  - StimulusDisplay (lines 6-33) receives a single `stimulus` object with `type`, `content`, `source`
  - FRQQuestionDisplay uses `displayStimulus = stimulus || question.stimulus` (line 94) - single object
  - StimulusDisplay renders IMAGE/CHART differently from TEXT/PASSAGE/DOCUMENT
  - No handling for an array of stimuli

- **Gap:** DBQ questions should display multiple historical documents. The current data model and display only support one stimulus per question.

- **Dependencies:**
  - Data model in Firestore may need to support `stimuli` (array) in addition to `stimulus` (object)
  - FRQQuestionDisplay needs modification
  - StimulusDisplay needs a wrapper for multi-document navigation
  - Test seed data may need updating

### Fix Plan

#### Step 1: Create MultiStimulusDisplay wrapper component
**File:** `src/apBoost/components/FRQQuestionDisplay.jsx`
**Action:** Add new component above existing StimulusDisplay
**Details:**
- Create a component that handles an array of stimuli
- Include tab/document navigation for switching between documents
- Show document number indicator (e.g., "Document 1 of 3")
- Pattern: Follow existing StimulusDisplay styling

```jsx
/**
 * Multi-stimulus display for DBQ with document navigation
 */
function MultiStimulusDisplay({ stimuli }) {
  const [activeIndex, setActiveIndex] = useState(0)

  if (!stimuli || stimuli.length === 0) return null
  if (stimuli.length === 1) {
    return <StimulusDisplay stimulus={stimuli[0]} />
  }

  return (
    <div className="space-y-3">
      {/* Document tabs */}
      <div className="flex gap-2 border-b border-border-default pb-2">
        {stimuli.map((s, idx) => (
          <button
            key={idx}
            onClick={() => setActiveIndex(idx)}
            className={`px-3 py-1.5 text-sm rounded-t-[--radius-button] transition-colors
              ${idx === activeIndex
                ? 'bg-brand-primary text-white'
                : 'bg-muted text-text-secondary hover:bg-hover'
              }`}
          >
            Document {idx + 1}
          </button>
        ))}
      </div>

      {/* Active document */}
      <StimulusDisplay stimulus={stimuli[activeIndex]} />

      {/* Document count indicator */}
      <div className="text-text-muted text-xs text-center">
        Document {activeIndex + 1} of {stimuli.length}
      </div>
    </div>
  )
}
```

#### Step 2: Update FRQQuestionDisplay to handle array or single stimulus
**File:** `src/apBoost/components/FRQQuestionDisplay.jsx`
**Action:** Modify
**Details:**
- Update line 94 to handle both `stimulus` (object) and `stimuli` (array)
- Add logic to choose between StimulusDisplay and MultiStimulusDisplay
- Maintain backward compatibility with single stimulus

```jsx
// Around line 94, replace:
const displayStimulus = stimulus || question.stimulus

// With:
const displayStimulus = stimulus || question.stimulus
const displayStimuli = question.stimuli // Array of documents for DBQ

// In the render (around line 107), replace:
<StimulusDisplay stimulus={displayStimulus} />

// With:
{displayStimuli && displayStimuli.length > 0 ? (
  <MultiStimulusDisplay stimuli={displayStimuli} />
) : (
  <StimulusDisplay stimulus={displayStimulus} />
)}
```

#### Step 3: Add useState import
**File:** `src/apBoost/components/FRQQuestionDisplay.jsx`
**Action:** Modify
**Details:**
- Add `useState` to imports at top of file for MultiStimulusDisplay component

```jsx
import { useState } from 'react'
```

### Verification Steps
1. Create a test DBQ question with multiple documents in `question.stimuli` array
2. Load the DBQ question - verify document tabs appear
3. Click between tabs - verify content switches correctly
4. Verify single-stimulus questions still work (backward compatibility)
5. Test on mobile viewport - ensure tabs are accessible

### Potential Risks
- **Risk:** Existing seed data uses `stimulus` not `stimuli`
  - **Mitigation:** Backward compatible - falls back to single StimulusDisplay
- **Risk:** Long document titles overflow tabs
  - **Mitigation:** Use numbered tabs ("Document 1") not titles
- **Risk:** Many documents make tabs unusable
  - **Mitigation:** For >5 docs, consider dropdown or scrollable tabs (future enhancement)

---

## Issue 3: SAQ Manual Grading Verification

### Audit Finding
- **Status:** ❓ Unable to Verify Directly
- **Criterion:** "Requires manual grading"
- **Current State:** Infrastructure appears to support manual grading but needs verification.

### Code Analysis
- **Relevant Files:**
  - [useTestSession.js](src/apBoost/hooks/useTestSession.js) (lines 79-80) - SAQ included in frqTypes
  - [apScoringService.js](src/apBoost/services/apScoringService.js) (lines 122-123) - PENDING status for FRQ/MIXED sections
  - [apGradingService.js](src/apBoost/services/apGradingService.js) (full file) - Complete grading workflow

- **Current Implementation:**
  ```javascript
  // useTestSession.js:79-80
  const frqTypes = [QUESTION_TYPE.FRQ, QUESTION_TYPE.SAQ, QUESTION_TYPE.DBQ]

  // apScoringService.js:122-123
  const hasFRQ = test.sections.some(s =>
    s.sectionType === SECTION_TYPE.FRQ || s.sectionType === SECTION_TYPE.MIXED
  )
  const gradingStatus = hasFRQ ? GRADING_STATUS.PENDING : GRADING_STATUS.NOT_NEEDED
  ```

- **Verification Result:** ✅ **IMPLEMENTED CORRECTLY**
  - SAQ is included in `frqTypes` array
  - Any section containing FRQ-type questions gets `gradingStatus: PENDING`
  - `apGradingService.js` provides complete manual grading infrastructure:
    - `getPendingGrades()` - retrieves submissions awaiting grading
    - `getResultForGrading()` - fetches full submission with questions
    - `saveGrade()` - saves teacher grades with sub-scores and comments
    - `calculateFRQScore()` - sums up sub-question scores

### Fix Plan

**No code changes needed.** The implementation is complete.

### Verification Steps
1. Complete an SAQ test as a student
2. Verify test result has `gradingStatus: 'PENDING'`
3. As teacher, access grading interface - verify SAQ appears in pending list
4. Grade the SAQ - verify scores are saved correctly

### Potential Risks
None - implementation is verified as correct.

---

## Issue 4: DBQ Manual Grading Verification

### Audit Finding
- **Status:** ❓ Unable to Verify Directly
- **Criterion:** "Requires manual grading"
- **Current State:** Same infrastructure as SAQ, needs verification.

### Code Analysis
- **Relevant Files:** Same as Issue 3

- **Current Implementation:**
  - DBQ is included alongside SAQ and FRQ in `frqTypes` array (useTestSession.js:79-80)
  - Uses identical grading pathway as SAQ
  - All FRQ-type questions require manual grading via teacher interface

- **Verification Result:** ✅ **IMPLEMENTED CORRECTLY**
  - DBQ is treated identically to SAQ and FRQ for grading purposes
  - Test results get `gradingStatus: PENDING`
  - Teacher grading interface handles all FRQ types uniformly

### Fix Plan

**No code changes needed.** The implementation is complete.

### Verification Steps
1. Complete a DBQ test as a student
2. Verify test result has `gradingStatus: 'PENDING'`
3. As teacher, access grading interface - verify DBQ appears in pending list
4. Grade the DBQ including sub-question scores - verify saves correctly

### Potential Risks
None - implementation is verified as correct.

---

## Implementation Order

Recommended order to implement fixes (considering dependencies):

1. **Issue 1: FRQTextInput onBlur** - Independent, quick win, improves data safety
2. **Issue 2: DBQ Multi-Document Support** - Requires more changes but no dependencies on Issue 1
3. **Issue 3 & 4** - No changes needed, already verified as correct

## Cross-Cutting Concerns

### Data Model Consideration
For Issue 2 (multi-document DBQ), the Firestore question document may need both fields:
- `stimulus` (object) - for single-stimulus questions (backward compatible)
- `stimuli` (array) - for multi-document DBQ questions

Seed data scripts should be updated to include sample DBQ questions with multiple documents.

### Component Reusability
The `MultiStimulusDisplay` component created for Issue 2 could be reused for any future question types that need multiple documents/images.

## Notes for Implementer

1. **Issue 1 is a 5-minute fix** - Just add onBlur prop and handler
2. **Issue 2 is 15-20 minutes** - Create new component, update existing component
3. **Issues 3 & 4 require no code changes** - Just testing verification
4. **Test with existing seed data first** - Ensure backward compatibility before adding multi-doc support
5. **The queue system is robust** - Don't over-engineer the blur handler; the existing queue mechanism handles edge cases well

## Files Summary

| File | Changes Required |
|------|-----------------|
| `src/apBoost/components/FRQTextInput.jsx` | Add onBlur prop and handler |
| `src/apBoost/pages/APTestSession.jsx` | Pass onBlur to FRQTextInput |
| `src/apBoost/components/FRQQuestionDisplay.jsx` | Add MultiStimulusDisplay, update to handle stimuli array |
| `src/apBoost/services/apScoringService.js` | No changes needed (verified) |
| `src/apBoost/services/apGradingService.js` | No changes needed (verified) |

---

## Part 2: Codebase Facts

# CODEBASE_FACTS__UNK__2.3.1_to_2.5.md

**Generated:** 2026-01-14
**Inspector:** Claude Agent (Repo Inspector Mode)
**Scope:** FRQ textarea persistence, offline queue, DBQ stimuli, manual grading

---

## 1) Canonical Data Schema / Source-of-Truth

**Found: Yes**

### Student Session Answer State

**Source:** `src/apBoost/hooks/useTestSession.js`

- **Local state:** `answers` is a `Map<questionId, answer>` (line 40)
- **For MCQ:** `answer` is a string (choice letter)
- **For FRQ with sub-questions:** `answer` is an object `{ a: "...", b: "...", c: "..." }` (lines 337-342)

```javascript
// useTestSession.js:337-342
if (isFRQQuestion && position.subQuestionLabel) {
  const existing = next.get(questionId) || {}
  next.set(questionId, {
    ...existing,
    [position.subQuestionLabel]: answer
  })
}
```

**Firestore collection:** `ap_session_state` (defined in `apTypes.js:94`)

### Question Stimulus Fields

**Source:** `src/apBoost/utils/apTypes.js:56-62`

- **STIMULUS_TYPE enum:** `TEXT`, `IMAGE`, `PASSAGE`, `DOCUMENT`, `CHART`
- **Question model has `stimulus` (singular object)** - confirmed in:
  - `QuestionDisplay.jsx:74`: `const displayStimulus = stimulus || question.stimulus`
  - `FRQQuestionDisplay.jsx:94`: `const displayStimulus = stimulus || question.stimulus`

**Evidence for single stimulus (NOT array):**
```javascript
// FRQQuestionDisplay.jsx:94
const displayStimulus = stimulus || question.stimulus

// QuestionDisplay.jsx:74
const displayStimulus = stimulus || question.stimulus
```

**`question.stimuli` (plural array):** NOT FOUND in actual code
- Searched terms: `.stimuli`, `question.stimuli`
- Only result: `apTypes.js:93` defines collection name `STIMULI: 'ap_stimuli'`

### Grading Status Fields

**Source:** `src/apBoost/utils/apTypes.js:42-47`

```javascript
export const GRADING_STATUS = {
  NOT_NEEDED: 'NOT_NEEDED',
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETE: 'COMPLETE',
}
```

**Where set:** `src/apBoost/services/apScoringService.js:122-123`
```javascript
const hasFRQ = test.sections.some(s => s.sectionType === SECTION_TYPE.FRQ || s.sectionType === SECTION_TYPE.MIXED)
const gradingStatus = hasFRQ ? GRADING_STATUS.PENDING : GRADING_STATUS.NOT_NEEDED
```

**Key Files Opened:**
- `src/apBoost/hooks/useTestSession.js`
- `src/apBoost/utils/apTypes.js`
- `src/apBoost/components/QuestionDisplay.jsx`
- `src/apBoost/components/FRQQuestionDisplay.jsx`
- `src/apBoost/services/apScoringService.js`

---

## 2) Write Paths

**Found: Yes**

### FRQ Answer Write Path

1. **User types in FRQTextInput** → `onChange` prop called with new text value
2. **APTestSession.jsx:443** passes `onChange={setAnswer}` to FRQTextInput
3. **useTestSession.setAnswer (lines 328-359):**
   - Updates local state immediately (optimistic)
   - Calls `addToQueue({ action: 'ANSWER_CHANGE', payload: { questionId, value, subQuestionLabel } })`
4. **useOfflineQueue.addToQueue (lines 125-160):**
   - Stores item in IndexedDB with `status: 'PENDING'`
   - Schedules flush with 1000ms debounce (line 155)
5. **useOfflineQueue.flushQueue (lines 173-266):**
   - Reads pending items from IndexedDB
   - Builds Firestore update object
   - Writes to `ap_session_state` collection

### FRQTextInput State Management

**FRQTextInput is fully controlled (no internal state):**
```javascript
// FRQTextInput.jsx:11-19 - Props definition
export default function FRQTextInput({
  subQuestion,
  value = '',       // <-- Controlled from parent
  onChange,
  disabled = false,
  ...
})
```

```javascript
// FRQTextInput.jsx:64-68 - Textarea element
<textarea
  ref={textareaRef}
  value={value}              // <-- From props
  onChange={handleChange}    // <-- Calls props.onChange
  ...
/>
```

### Navigation Triggers

- **Navigation (goNext, goPrevious, goToQuestion, goToFlatIndex):** Queues `NAVIGATION` action
- **Submit test (submitTest):** Calls `flushQueue()` before creating result (line 406-408)

### Grading Write Path

1. **Teacher clicks "Grade" in APGradebook** → opens GradingPanel
2. **GradingPanel.handleSaveDraft/handleMarkComplete** → calls `saveGrade()`
3. **apGradingService.saveGrade (lines 165-210):**
   - Writes `frqGrades`, `gradingStatus`, `gradedBy`, `gradedAt` to `ap_test_results`
   - If COMPLETE: also calculates `frqScore` and updates totals

### Write Paths Summary

| Event | Handler | Queue/Service | Persistence |
|-------|---------|---------------|-------------|
| FRQ text change | `FRQTextInput.handleChange` → `setAnswer` | `addToQueue(ANSWER_CHANGE)` | IndexedDB → Firestore (debounced) |
| Navigation | `goToFlatIndex` | `addToQueue(NAVIGATION)` | IndexedDB → Firestore (debounced) |
| Timer tick | `handleTimerTick` (every 30s) | `addToQueue(TIMER_SYNC)` | IndexedDB → Firestore (debounced) |
| Test submit | `submitTest` | `flushQueue()` then `createTestResult()` | Immediate flush + new doc |
| Grade save | `saveGrade` | Direct Firestore write | Immediate (no queue) |

**Key Files Opened:**
- `src/apBoost/components/FRQTextInput.jsx`
- `src/apBoost/pages/APTestSession.jsx`
- `src/apBoost/hooks/useTestSession.js`
- `src/apBoost/hooks/useOfflineQueue.js`
- `src/apBoost/services/apGradingService.js`

---

## 3) Offline/Resilience Mechanics

**Found: Yes**

### Queue Storage Mechanism

**Library:** Native IndexedDB (no wrapper library like localforage)
**Database name:** `ap_boost_queue` (line 9)
**Store name:** `actions` (line 10)
**Key path:** `id` (auto-generated timestamp + random)

```javascript
// useOfflineQueue.js:8-11
const DB_NAME = 'ap_boost_queue'
const STORE_NAME = 'actions'
const DB_VERSION = 1
```

**Queue item schema (lines 131-138):**
```javascript
const queueItem = {
  id: generateId(),
  sessionId,
  localTimestamp: Date.now(),
  action: action.action,
  payload: action.payload,
  status: 'PENDING',
}
```

### Debounce Timing

**Confirmed: 1000ms (1 second)**

```javascript
// useOfflineQueue.js:154-156
if (isOnline) {
  scheduleFlush(1000) // 1 second debounce
}
```

Also used when coming back online (line 90):
```javascript
scheduleFlush(1000)
```

### Flush Triggers

1. **Debounce timer:** 1000ms after `addToQueue` if online (line 155)
2. **Coming back online:** 1000ms after `online` event (line 90)
3. **Explicit call:** `submitTest()` calls `flushQueue()` before creating result (useTestSession.js:406-408)
4. **Exponential backoff retry:** 2s, 4s, 8s, 16s on failure (lines 258-261)

### Lifecycle Handling

**beforeunload (useTestSession.js:209-220):**
```javascript
const handleBeforeUnload = (e) => {
  if (queueLength > 0) {
    e.preventDefault()
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
    return e.returnValue
  }
}
```
- **Purpose:** Warning dialog only
- **Does NOT persist/flush:** Just shows browser warning

**visibilitychange:**
- Used in `useHeartbeat.js:101-113` for heartbeat only
- **NOT used in useOfflineQueue** for flushing

**pagehide:** NOT FOUND
**navigator.sendBeacon:** NOT FOUND (only in fix plan docs)

### Idempotency / Dedupe Behavior

**CRITICAL BUG FOUND:** For FRQ sub-questions, there is no proper merge behavior.

```javascript
// useOfflineQueue.js:205-206
case 'ANSWER_CHANGE':
  updates[`answers.${item.payload.questionId}`] = item.payload.value
```

- `item.payload.value` is just the current sub-answer text (e.g., "answer for part a")
- `item.payload.subQuestionLabel` exists but is NEVER USED
- Multiple ANSWER_CHANGE for same question ID will overwrite each other
- **Result:** If student types in (a) then (b), only (b) survives flush

**Key Files Opened:**
- `src/apBoost/hooks/useOfflineQueue.js`
- `src/apBoost/hooks/useTestSession.js`
- `src/apBoost/hooks/useHeartbeat.js`

---

## 4) UI/Flow Entry Points

**Found: Yes**

### FRQTextInput Rendering

**Location:** `src/apBoost/pages/APTestSession.jsx:439-445`

```javascript
{isFRQQuestion ? (
  <FRQTextInput
    subQuestion={currentQuestion?.subQuestions?.find(sq => sq.label === subQuestionLabel)}
    value={currentAnswer || ''}
    onChange={setAnswer}
    disabled={isSubmitting || isInvalidated}
  />
) : (
  <AnswerInput ... />
)}
```

**Props wired:**
- `value`: from `currentAnswer` (computed in useTestSession.js:312-325)
- `onChange`: `setAnswer` from useTestSession
- `disabled`: based on `isSubmitting` or `isInvalidated`
- **NO `onBlur` prop passed**

### FRQQuestionDisplay / StimulusDisplay Usage

**Location:** `src/apBoost/components/QuestionDisplay.jsx:76-89`

```javascript
const frqTypes = [QUESTION_TYPE.FRQ, QUESTION_TYPE.SAQ, QUESTION_TYPE.DBQ]
if (frqTypes.includes(question.questionType)) {
  return (
    <FRQQuestionDisplay
      question={question}
      questionNumber={questionNumber}
      subQuestionLabel={subQuestionLabel}
      stimulus={displayStimulus}     // <-- Single object
    >
      {children}
    </FRQQuestionDisplay>
  )
}
```

**Stimulus selection (QuestionDisplay.jsx:74):**
```javascript
const displayStimulus = stimulus || question.stimulus
```
- Assumes single object, not array
- No DBQ-specific branching for multi-document stimuli

### DBQ-specific UI Branching

**NOT FOUND**
- `QUESTION_TYPE.DBQ` exists in apTypes.js
- DBQ is handled identically to FRQ/SAQ in QuestionDisplay
- No special rendering for multiple documents

### Teacher Grading UI Entry Points

**Route:** `/ap/teacher/gradebook` (implied from APGradebook.jsx)

**Page:** `src/apBoost/pages/APGradebook.jsx`
- Loads pending results via `getPendingGrades()` (line 168)
- Opens `GradingPanel` when "Grade" clicked (lines 182-185)

**Component:** `src/apBoost/components/grading/GradingPanel.jsx`
- Loads result via `getResultForGrading(resultId)` (line 261)
- Saves via `saveGrade(resultId, grades, status, teacherId, annotatedPdfUrl)` (lines 291, 305)

**Service functions called:**
- `getPendingGrades(teacherId, filters)` - apGradingService.js:26
- `getResultForGrading(resultId)` - apGradingService.js:108
- `saveGrade(resultId, grades, status, teacherId, annotatedPdfUrl)` - apGradingService.js:165

**Key Files Opened:**
- `src/apBoost/pages/APTestSession.jsx`
- `src/apBoost/components/QuestionDisplay.jsx`
- `src/apBoost/components/FRQQuestionDisplay.jsx`
- `src/apBoost/pages/APGradebook.jsx`
- `src/apBoost/components/grading/GradingPanel.jsx`

---

## 5) Must-Answer Questions

### Question 1: FRQTextInput onBlur Support

**Found: No - ABSENT**

FRQTextInput does NOT have any onBlur support:

```javascript
// FRQTextInput.jsx:11-19 - Full props list
export default function FRQTextInput({
  subQuestion,
  value = '',
  onChange,
  disabled = false,
  maxLength = 10000,
  showCharCount = true,
  placeholder = 'Type your response here...',
})
```

```javascript
// FRQTextInput.jsx:64-81 - Textarea element (no onBlur)
<textarea
  ref={textareaRef}
  value={value}
  onChange={handleChange}
  disabled={disabled}
  placeholder={placeholder}
  className={...}
  style={{ minHeight: '150px', maxHeight: '400px' }}
/>
```

**Evidence:** No `onBlur` in props destructuring (lines 11-19), no `onBlur` on textarea element (lines 64-81).

---

### Question 2: FRQTextInput Controlled vs Uncontrolled

**Found: Yes - FULLY CONTROLLED**

- `value` comes from props (line 13: `value = ''`)
- No `useState` for text content
- Textarea uses `value={value}` directly (line 66)
- Changes call `onChange(newValue)` from props (line 37)

```javascript
// FRQTextInput.jsx:34-39
const handleChange = (e) => {
  const newValue = e.target.value
  if (newValue.length <= maxLength) {
    onChange(newValue)   // <-- Parent controls state
  }
}
```

---

### Question 3: APTestSession Handler for FRQTextInput

**Found: Yes**

```javascript
// APTestSession.jsx:439-445
<FRQTextInput
  subQuestion={currentQuestion?.subQuestions?.find(sq => sq.label === subQuestionLabel)}
  value={currentAnswer || ''}
  onChange={setAnswer}    // <-- Handler from useTestSession
  disabled={isSubmitting || isInvalidated}
/>
```

`setAnswer` comes from useTestSession hook (line 74 destructured, line 443 passed).

---

### Question 4: setAnswer Action in useTestSession

**Found: Yes**

```javascript
// useTestSession.js:328-359
const setAnswer = useCallback((answer) => {
  const questionId = position.questionId
  if (!questionId || !session?.id) return

  // Update local state immediately (optimistic)
  setAnswers(prev => {
    const next = new Map(prev)
    if (isFRQQuestion && position.subQuestionLabel) {
      const existing = next.get(questionId) || {}
      next.set(questionId, {
        ...existing,
        [position.subQuestionLabel]: answer
      })
    } else {
      next.set(questionId, answer)
    }
    return next
  })

  // Queue for sync
  addToQueue({
    action: 'ANSWER_CHANGE',
    payload: {
      questionId,
      value: answer,
      subQuestionLabel: position.subQuestionLabel // null for MCQ
    }
  })
}, [...])
```

**Action object shape:**
```javascript
{
  action: 'ANSWER_CHANGE',
  payload: {
    questionId: string,
    value: string,              // Just the current sub-answer text
    subQuestionLabel: string | null
  }
}
```

---

### Question 5: Debounce Interval

**Found: Yes - 1000ms (1 second)**

```javascript
// useOfflineQueue.js:154-156
if (isOnline) {
  scheduleFlush(1000) // 1 second debounce
}
```

Also at line 90:
```javascript
scheduleFlush(1000)
```

---

### Question 6: Navigation Away / Tab Close Persistence

**Found: Yes - WARNING ONLY, NO PERSISTENCE**

**beforeunload handler (useTestSession.js:209-220):**
```javascript
const handleBeforeUnload = (e) => {
  if (queueLength > 0) {
    e.preventDefault()
    e.returnValue = 'You have unsaved changes. Are you sure you want to leave?'
    return e.returnValue
  }
}
```

- Shows browser warning dialog if queue has pending items
- Does NOT call `flushQueue()` or persist data
- Does NOT use `sendBeacon`

**visibilitychange:** Only used in useHeartbeat for heartbeat, NOT for queue flush
**pagehide:** NOT FOUND

---

### Question 7: question.stimuli Array Support

**Found: No - NOT IMPLEMENTED**

Searched for `.stimuli` in all `.js` and `.jsx` files:
- Only result: `apTypes.js:93` defines Firestore collection `STIMULI: 'ap_stimuli'`
- No code accesses `question.stimuli` as an array of documents

**Evidence:**
```bash
Grep pattern: stimuli
Results in code files:
  src/apBoost/utils/apTypes.js:93  STIMULI: 'ap_stimuli',  (collection name only)
```

---

### Question 8: Stimulus Selection in FRQQuestionDisplay

**Found: Yes - Single Object Assumed**

```javascript
// FRQQuestionDisplay.jsx:89-95
stimulus,            // Props
...
const displayStimulus = stimulus || question.stimulus  // Single object
```

```javascript
// QuestionDisplay.jsx:74
const displayStimulus = stimulus || question.stimulus
```

- Uses `question.stimulus` (singular)
- Assumes single object, not array
- Same pattern in both components

---

### Question 9: gradingStatus Computation

**Found: Yes**

```javascript
// apScoringService.js:122-123
const hasFRQ = test.sections.some(s =>
  s.sectionType === SECTION_TYPE.FRQ ||
  s.sectionType === SECTION_TYPE.MIXED
)
const gradingStatus = hasFRQ ? GRADING_STATUS.PENDING : GRADING_STATUS.NOT_NEEDED
```

**Logic:**
- If ANY section is FRQ or MIXED → `gradingStatus = PENDING`
- Otherwise → `gradingStatus = NOT_NEEDED`
- SAQ and DBQ are question types within FRQ sections, so they trigger PENDING via section type

---

### Question 10: End-to-End Grading Write Flow

**Found: Yes**

**Service Functions:**

1. **getPendingGrades** (apGradingService.js:26-101)
   - Queries `ap_test_results` where `gradingStatus` in [PENDING, IN_PROGRESS]
   - Returns array with studentName and testTitle enriched

2. **getResultForGrading** (apGradingService.js:108-154)
   - Fetches single result by ID
   - Enriches with student info and FRQ questions

3. **saveGrade** (apGradingService.js:165-210)
   - Updates `frqGrades`, `gradingStatus`, `gradedBy`, `gradedAt`
   - If COMPLETE: calculates `frqScore`, updates totals

**UI Callers:**

**APGradebook.jsx:**
```javascript
// Line 168 - Load results
const data = await getPendingGrades(user.uid, filters)

// Lines 182-185 - Open grading panel
const handleGrade = (resultId) => {
  setSelectedResultId(resultId)
  setIsPanelOpen(true)
}
```

**GradingPanel.jsx:**
```javascript
// Line 261 - Load result for grading
const data = await getResultForGrading(resultId)

// Line 291 - Save draft
await saveGrade(resultId, grades, GRADING_STATUS.IN_PROGRESS, teacherId)

// Line 305 - Mark complete
await saveGrade(resultId, grades, GRADING_STATUS.COMPLETE, teacherId, annotatedPdfUrl)
```

---

## Summary of Critical Findings

| Finding | Severity | Location |
|---------|----------|----------|
| No onBlur on FRQTextInput | Medium | FRQTextInput.jsx |
| FRQ sub-answer overwrite bug | **HIGH** | useOfflineQueue.js:205-206 |
| No visibilitychange flush | Medium | useOfflineQueue.js |
| No sendBeacon on beforeunload | Medium | useTestSession.js:209-220 |
| No `question.stimuli` array support | Medium | All display components |
| beforeunload only warns, no persist | Medium | useTestSession.js:209-220 |

**Most Critical:** `ANSWER_CHANGE` in useOfflineQueue does NOT handle `subQuestionLabel` - FRQ sub-answers will overwrite each other on flush.
